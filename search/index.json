[{"content":"一、简述Django 中哪里用到了线程？哪里用到了协程？哪里用到了进程？\rDjango 是一个基于 Python 的高级 Web 框架，它本身并不直接处理线程、协程或进程的创建和管理，而是依赖于其运行的环境（如 Web 服务器、数据库等）以及可能的第三方库来处理并发和并行。然而，在 Django 的不同部分和与其相关的生态系统中，你可能会遇到这些概念。\n1. 线程（Threads）\rWeb 服务器：Django 通常部署在 WSGI 服务器上，如 Gunicorn 或 uWSGI，这些服务器可能会使用线程来处理并发请求。例如，Gunicorn 可以通过配置工作进程和工作线程的数量来优化并发性能。 数据库连接：Django 的数据库连接通常是线程安全的，这意味着每个线程可以有自己的数据库连接。Django 的 ORM 提供了数据库连接池的概念，以支持高效的线程间数据库访问。 内部操作：在 Django 代码中直接使用线程（通过 Python 的 threading 模块）是不常见的，因为 Django 的设计通常是同步的。但是，开发者可能会在某些特定情况下使用线程来执行后台任务或处理耗时的操作。 2. 协程（Coroutines）\r异步视图和中间件：从 Django 3.1 开始，Django 支持异步视图和中间件，这允许开发者使用 async 和 await 关键字编写异步代码。这些异步视图和中间件通常与 ASGI 服务器（如 Daphne 或 Uvicorn）一起使用，这些服务器支持基于协程的并发模型。 Channels：Channels 是一个 Django 的第三方库，它为 Django 添加了实时、双向通信的能力。Channels 基于 ASGI，并使用协程来处理 WebSocket、HTTP2 和其他协议。 数据库操作：虽然 Django 的默认 ORM 是同步的，但有一些第三方库（如 databases）提供了异步的数据库操作支持，这些操作可以与协程一起使用。 3. 进程（Processes）\rWeb 服务器：像 Gunicorn 这样的 WSGI 服务器通常使用多个进程来处理请求，每个进程可以有自己的线程池。这种方式有助于隔离不同请求之间的状态，并提供了更高的稳定性。 后台任务：Django 通常与 Celery 这样的任务队列一起使用来处理后台任务。Celery 可以配置为使用不同的并发模型，包括多进程，来执行异步任务。 多进程模式：在某些情况下，开发者可能会选择使用 Python 的 multiprocessing 模块在 Django 应用中直接创建和管理进程。这通常用于执行 CPU 密集型任务或需要隔离状态的操作。 总的来说，Django 框架本身并不直接管理线程、协程或进程，但这些概念在 Django 的部署、扩展和并发处理中扮演着重要角色。开发者可以根据需要选择适当的工具和库来优化其应用的性能和可扩展性。\n二、什么是跨域以及解决方法\r跨域指的是在浏览器中，由于同源策略的限制，网页从一个源（协议、域名和端口）请求另一个源的资源时，浏览器会阻止这种请求。这个策略旨在保护用户的数据安全，但在开发中可能会遇到跨域问题，尤其是在进行 API 请求时。\n跨域的解决方法\rCORS（跨源资源共享）：\n在服务器端设置 Access-Control-Allow-Origin 响应头，允许特定的源访问资源。 可以配置允许的 HTTP 方法、头部和凭据等。 JSONP（JSON with Padding）：\n通过动态创建 \u0026lt;script\u0026gt; 标签的方式，利用 \u0026lt;script\u0026gt; 标签不受同源策略限制的特性来请求跨域数据。 适用于 GET 请求，但只支持简单数据返回。 代理服务器：\n在同源的服务器上设置一个代理，将跨域请求转发到目标服务器。客户端向同源的代理发起请求，代理再将请求转发到目标服务器。 WebSocket：\nWebSocket 连接不受同源策略限制，可以在不同源之间建立实时双向通信。 iframe + postMessage：\n利用 postMessage 方法，在同源的 iframe 中与父页面进行安全的跨域通信。 Nginx 反向代理：\n在 Nginx 中配置反向代理，将请求转发到不同的后端服务，同时保持同源的外部表现。 总结\r跨域问题是由于浏览器的同源策略造成的，开发者可以通过 CORS、JSONP、代理等方法来解决这一问题，确保前后端的正常通信和数据交换。\n三、代理服务器和反向代理的区别\r代理服务器和反向代理是两种不同的网络代理概念，它们的功能和应用场景有所不同：\n1. 代理服务器（Forward Proxy）\r定义：代理服务器（也称为正向代理）是客户端和目标服务器之间的中介。客户端将请求发送到代理服务器，代理服务器再将请求转发给目标服务器，并将响应返回给客户端。 主要用途： 匿名浏览：用户通过代理服务器隐藏自己的真实 IP 地址。 访问控制：可以用于过滤内容、限制访问某些网站或资源。 缓存：可以缓存常用资源，提高访问速度。 2. 反向代理（Reverse Proxy）\r定义：反向代理是在客户端和多个后端服务器之间的中介。客户端请求发送到反向代理服务器，反向代理再将请求转发到适当的后端服务器，并将响应返回给客户端。 主要用途： 负载均衡：可以将请求分发到多台后端服务器，以实现负载均衡，提高系统的可用性和性能。 SSL/TLS 终止：可以处理 SSL 加密和解密，减轻后端服务器的负担。 缓存和压缩：可以对响应进行缓存和压缩，提高性能。 安全性：可以隐藏后端服务器的真实地址，增加安全性。 总结\r代理服务器主要服务于客户端，帮助客户端访问其他服务器，常用于匿名、过滤和缓存等场景。 反向代理主要服务于服务器端，帮助后端服务器处理请求，常用于负载均衡、安全性和性能优化等场景。 两者的核心区别在于它们的工作方向和服务对象，代理服务器面向客户端，反向代理面向服务器。\n四、如何实现用户的登陆认证\r在 Django 中实现用户的登录认证通常涉及以下步骤：\n设置用户模型 确保项目中有用户模型，Django 默认提供了一个 User 模型，可以使用或自定义。 安装和配置 Django REST Framework（如果是 API 认证） 安装 DRF： 1 pip install djangorestframework 在 settings.py 中添加 DRF： 1 2 3 4 INSTALLED_APPS = [ \u0026#39;rest_framework\u0026#39;, # 其他应用 ] 编写认证视图 创建登录视图，使用 Django 提供的 authenticate 和 login 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from django.contrib.auth import authenticate, login from rest_framework.response import Response from rest_framework import status from rest_framework.views import APIView class LoginView(APIView): def post(self, request): username = request.data.get(\u0026#39;username\u0026#39;) password = request.data.get(\u0026#39;password\u0026#39;) user = authenticate(request, username=username, password=password) if user is not None: login(request, user) # 将用户登录 return Response({\u0026#39;message\u0026#39;: \u0026#39;Login successful\u0026#39;}, status=status.HTTP_200_OK) else: return Response({\u0026#39;error\u0026#39;: \u0026#39;Invalid credentials\u0026#39;}, status=status.HTTP_401_UNAUTHORIZED) 设置 URL 路由 在 urls.py 中为登录视图添加路由：\n1 2 3 4 5 6 7 from django.urls import path from .views import LoginView urlpatterns = [ path(\u0026#39;login/\u0026#39;, LoginView.as_view(), name=\u0026#39;login\u0026#39;), # 其他路由 ] 前端请求 前端发送 POST 请求到 /login/，请求体中包含用户名和密码。 认证后的处理 成功登录后，可以返回用户信息或 JWT token，供后续请求使用。 对于 API，通常会使用 JWT 或其他 token 机制进行后续认证。 退出登录 也可以实现一个退出登录的视图，使用 logout 方法。\n1 2 3 4 5 6 from django.contrib.auth import logout class LogoutView(APIView): def post(self, request): logout(request) # 退出登录 return Response({\u0026#39;message\u0026#39;: \u0026#39;Logout successful\u0026#39;}, status=status.HTTP_200_OK) 总结\r通过上述步骤，您可以实现用户的登录认证，处理用户的登录和退出请求，并根据需求进行相应的用户信息管理和安全控制。根据项目需求，您还可以扩展认证方式，例如使用 JWT 或 OAuth 进行更复杂的认证。\n**五、如何将dict转换成url的格式\r要将字典（dict）转换为 URL 查询字符串的格式，可以使用 Python 的标准库中的 urllib 模块，具体方法如下：\n使用 urllib.parse 模块\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 import urllib.parse # 示例字典 data = { \u0026#39;name\u0026#39;: \u0026#39;John Doe\u0026#39;, \u0026#39;age\u0026#39;: 30, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;, \u0026#39;hobbies\u0026#39;: [\u0026#39;reading\u0026#39;, \u0026#39;traveling\u0026#39;] } # 使用 urlencode 将字典转换为查询字符串 query_string = urllib.parse.urlencode(data, doseq=True) print(query_string) 说明\rurlencode 方法会将字典转换为 URL 查询字符串的格式，支持将列表参数（如 hobbies）转换为多次出现的相同键。 doseq=True 参数确保列表中的每个值都被单独编码。 输出结果\r对于上述示例，输出将会是：\n1 name=John+Doe\u0026amp;age=30\u0026amp;city=New+York\u0026amp;hobbies=reading\u0026amp;hobbies=traveling 总结\r使用 urllib.parse 模块中的 urlencode 方法，可以轻松将字典转换为适合在 URL 中使用的查询字符串格式。这在处理 API 请求或生成链接时非常有用。\nReferences\rpython web框架django面试题 ","date":"2024-10-16T14:19:56+08:00","permalink":"https://leanmax.github.io/p/django%E9%9D%A2%E8%AF%95%E9%A2%98%E5%85%AD/","title":"Django面试题（六）"},{"content":"一、django的ContentType组件的作用？\rDjango 的 ContentType 组件是一个强大的工具，它提供了一种通用的方法来处理与模型相关的权限和关系。ContentType 是 Django 内置的应用程序，允许你以一种统一的方式处理与不同模型的交互。\n主要作用\r模型的通用引用：\nContentType 允许你以一种通用的方式引用任何模型，而不需要直接引用模型类。这对于动态操作模型非常有用。 实现通用的权限系统：\nDjango 的权限系统依赖于 ContentType，通过它，Django 可以为每个模型生成权限。例如，当你为模型创建权限时，Django 会使用 ContentType 来关联这些权限。 与通用关系配合使用：\n结合 GenericForeignKey，ContentType 允许你创建与不同模型的通用关系。这使得你可以在某个模型中保存对其他模型实例的引用，而不需要预先定义外键。 1 2 3 4 5 6 7 from django.contrib.contenttypes.fields import GenericForeignKey from django.contrib.contenttypes.models import ContentType class Comment(models.Model): content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE) object_id = models.PositiveIntegerField() content_object = GenericForeignKey(\u0026#39;content_type\u0026#39;, \u0026#39;object_id\u0026#39;) 上述示例中，Comment 模型可以与任何其他模型关联。\n动态获取模型信息：\n通过 ContentType，你可以动态获取与特定模型相关的信息，例如模型的名称、应用名称等。 1 2 3 4 from django.contrib.contenttypes.models import ContentType from myapp.models import MyModel content_type = ContentType.objects.get_for_model(MyModel) 创建和管理动态关系：\n使用 ContentType 可以方便地创建动态关系，例如在一个表中存储对不同类型模型的引用。这对于需要处理多种类型对象的场景非常有用，比如评论系统、标签系统等。 具体应用场景\r评论系统：允许用户对多种类型的对象（如文章、图片等）进行评论。 标签和分类：创建一个通用的标签系统，能够为多种模型打标签。 动态权限管理：为特定模型生成和管理权限，适应不同应用需求。 总结\rDjango 的 ContentType 组件提供了一种灵活、通用的方式来处理与模型相关的动态关系和权限管理。通过它，开发者可以轻松实现多态性和动态交互，极大地提高了 Django 应用的灵活性和扩展性。\n二、谈谈你对restful规范的认识？\rRESTful 规范是基于 REST（Representational State Transfer 表述性状态转移）架构风格的一组设计原则，旨在通过 HTTP 协议提供可扩展、灵活和易于维护的网络服务。以下是对 RESTful 规范的几个关键认识：\n资源导向 RESTful API 的核心是资源，资源通过 URI（Uniform Resource Identifier）进行标识。例如，用户资源可能对应于 /users，单个用户则是 /users/{id}。 HTTP 方法 RESTful API 利用 HTTP 方法来定义对资源的操作： GET：获取资源。 POST：创建资源。 PUT：更新资源。 PATCH：部分更新资源。 DELETE：删除资源。 无状态性 每个请求都应包含完成请求所需的所有信息，服务器不应存储客户端的状态。这使得系统更容易扩展和维护。 统一接口 RESTful API 应具有一致的接口，使客户端和服务器之间的交互简单明了。通过使用标准化的 URI 和 HTTP 方法，开发者可以轻松理解和使用 API。 三、接口的安全性和幂等性是什么意思？\r安全性是指外系统对接该接口的访问，不会使服务器资源的状态发生改变 幂等性是一个数学上的概念，在这里是指外系统对同一REST接口的多次访问，得到的资源最终状态是相同的。在网速不够快的情况下，客户端发送一个请求后不能立即得到响应，由于不能确定请求是否被成功提交，所以它有可能会再次发送另一个相同的请求，幂等性决定了第二个请求是否有效。 具体说明：\rGET 请求：\nHTTP的GET⽅法⽤于读取资源。GET⽅法是幂等的，因为读取同⼀个资源，总是得到相同的数据。 GET⽅法也是安全的，因为读取资源不会对其状态做改动。 PUT 请求：\nPUT⽅法是幂等的，即多次或者更新同⼀份数据，在服务器端对资源状态所产⽣的改变是相同的。 PUT⽅法不是安全的，有写动作的HTTP⽅法都不是安全的。 DELETE 请求：\n一般认为是幂等的。如果多次删除同一资源，第一次请求会删除成功，而后续请求由于资源已不存在，通常会返回相同的状态码（如 404），不影响结果。 DELETE是不安全的，请求会删除指定的资源，一旦执行，该资源将不再存在。 POST 请求：\n因为请求会改变服务器端资源的状态，因此不是安全的。 每次请求对服务器资源状态的改变并不是相同的，因此不是幂等的。 四、什么是RPC？\rRPC（Remote Procedure Call，远程过程调用）是一种协议，允许程序在不同的计算机上执行子程序或服务，就像调用本地函数一样。通过 RPC，客户端可以请求远程服务器执行某个过程，并获取结果，而无需关心网络通信的细节。\n主要特点：\r抽象化：\nRPC 隐藏了网络通信的复杂性，使开发者可以专注于业务逻辑，而不是底层的传输机制。 语言无关性：\nRPC 可以在不同编程语言之间进行调用，通常通过协议定义接口，确保不同系统可以互操作。 同步与异步：\nRPC 通常是同步的，客户端在等待响应时会阻塞，但也可以实现异步调用，以提高系统的响应能力。 使用协议：\n常见的 RPC 协议包括 HTTP（如 REST）、gRPC、Thrift 等，确保数据在客户端和服务器之间的传输。 典型应用场景：\r微服务架构：服务之间的通信。 分布式系统：不同节点之间的函数调用。 客户端-服务器模型：客户端请求服务器执行某些操作。 总结\rRPC 使得跨网络的函数调用变得简单和高效，广泛应用于现代分布式系统和微服务架构中。它通过抽象网络通信，允许开发者更专注于应用逻辑。\n五、为什么要使用API\r使用 API（应用程序编程接口）有多个重要原因，主要包括以下几点：\n1. 模块化与解耦\nAPI 允许不同的软件组件之间以标准化的方式进行通信，从而实现模块化设计。这种解耦使得各个部分可以独立开发、测试和维护，提高了系统的灵活性和可扩展性。 2. 重用与共享\nAPI 提供了重用代码的机会，可以在多个项目中使用相同的功能。通过 API，开发者可以共享功能模块，减少重复工作。 3. 标准化\nAPI 定义了一组标准化的接口，便于不同开发团队和系统之间的协作。遵循标准化接口可以减少理解和实现上的障碍。 4. 跨平台与跨语言\nAPI 通常是语言无关的，支持不同编程语言和平台之间的交互。这使得开发者可以在多种环境中使用相同的服务。 5. 易于集成\nAPI 使得不同应用程序之间的集成变得更加简单。例如，前端应用可以通过 API 调用后端服务，移动应用可以与服务器进行数据交互。 6. 扩展性\n通过 API，可以方便地添加新功能而不影响现有系统。服务可以随着需求的变化进行扩展，保持系统的灵活性。 7. 安全性\nAPI 可以通过身份验证和授权机制保护敏感数据。通过 API，可以控制对系统资源的访问，确保数据安全。 8. 支持自动化\nAPI 支持自动化流程，可以通过编程方式调用服务，实现自动化操作。这在 DevOps 和 CI/CD 流程中尤为重要。 9. 数据交互与服务调用\nAPI 使得应用程序能够方便地交换数据和调用服务，特别是在微服务架构中，各个服务之间的通信往往依赖于 API。 总结\n使用 API 带来了灵活性、可重用性和易于集成的优势，使得软件开发更高效、系统更稳定。无论是在开发新功能、实现系统集成，还是在提供服务，API 都是现代软件开发不可或缺的工具。\n六、为什么要使用django rest framework框架？\r使用Django REST framework（DRF）框架有以下几个主要原因：\n高效开发：DRF是一个强大且灵活的工具，建立在Django框架基础之上。它提供了许多现成的组件和功能，如序列化、视图、路由、认证、权限等，这些都可以帮助开发者快速构建Web API，从而提高开发效率。 统一的接口规范：DRF遵循RESTful设计原则，提供了统一的接口规范，使得前后端分离更加容易实现。同时，它也支持多种数据格式，如JSON、XML等，以满足不同客户端的需求。 良好的用户体验：DRF的Web browsable API为开发者提供了极大的便利。开发者可以直接在Web页面上测试API，无需编写额外的测试代码。此外，DRF还支持OAuth1a和OAuth2等认证策略，为用户提供了更安全、更可靠的身份验证方式。 强大的社区支持：DRF拥有庞大的用户群体和活跃的社区，这意味着当开发者遇到问题时，他们可以从社区获取帮助。此外，DRF还有丰富的第三方库和插件可供选择，以扩展其功能。 易于维护和扩展：由于DRF采用了模块化设计，因此它的各个组件可以独立地进行升级和维护。这使得开发者在需要对某个组件进行更新或替换时，无需对整个项目进行重构。同时，DRF还支持自定义开发，开发者可以根据自己的需求编写代码，以满足特定的业务需求。 综上所述，使用Django REST framework框架可以帮助开发者高效、快速地构建Web API，提供良好的用户体验，并享受到强大的社区支持和易于维护、扩展的优点。\n七、django rest framework框架中都有那些组件？\rDjango REST Framework (DRF) 提供了一系列组件，使得构建和管理 RESTful API 更加高效。以下是 DRF 中的一些主要组件：\n1. 序列化器（Serializers）\r用于将复杂数据类型（如模型实例）转换为 JSON 或其他内容类型，支持数据验证和转换。主要有： Serializer：基本的序列化器。 ModelSerializer：基于模型的序列化器，自动生成字段。 2. 视图（Views）\r定义 API 的行为。DRF 提供了多种类型的视图，包括： 函数视图：使用装饰器的简单视图。 类视图：基于类的视图（如 APIView 和 GenericAPIView），支持更灵活的行为。 视图集（ViewSets）：将多个相关的视图逻辑集中在一起，支持 CRUD 操作。 3. 路由（Routers）\r提供 URL 路由自动化，简化 API 路由的定义。通过使用路由，开发者可以轻松地为视图集生成 URL。 4. 认证（Authentication）\r提供多种身份验证机制，包括： BasicAuthentication：基本身份验证。 TokenAuthentication：基于令牌的身份验证。 SessionAuthentication：基于会话的身份验证。 JWTAuthentication：JSON Web Token 身份验证。 5. 权限（Permissions）\r控制用户对 API 资源的访问权限。DRF 提供多种内置权限类，如： IsAuthenticated：仅允许已认证用户访问。 IsAdminUser：仅允许管理员访问。 AllowAny：允许所有用户访问。 6. 过滤（Filters）\r提供多种数据过滤机制，支持根据查询参数过滤 API 返回的数据。例如，DRF 支持 Django 的 ORM 过滤器和自定义过滤器。 7. 分页（Pagination）\r提供多种分页策略，方便处理大量数据的展示。内置的分页类包括： PageNumberPagination：基于页码的分页。 LimitOffsetPagination：基于限制和偏移量的分页。 CursorPagination：基于游标的分页。 8. 文档（Documentation）\rDRF 支持生成 API 文档，便于开发者和用户了解 API 的使用方式，通常与第三方工具（如 Swagger 或 CoreAPI）结合使用。 9. 异常处理（Exception Handling）\r提供内置的异常处理机制，便于捕获和返回错误信息。 10. 测试工具（Testing）\r提供测试工具，便于对 API 进行单元测试和集成测试，确保系统的稳定性。 总结\rDjango REST Framework 的组件丰富，能够满足不同类型 API 开发的需求，极大地提高了开发效率和 API 的可维护性。通过这些组件，开发者可以方便地构建灵活、安全和高效的 RESTful API。\n八、django rest framework框架中的视图都可以继承哪些类？\r在 Django REST Framework (DRF) 中，视图可以通过继承不同的基类来实现不同的功能和行为。主要的视图类包括：\n1. APIView\r基础视图类，提供了对请求和响应的基本处理。可以通过定义 get(), post(), put(), delete() 等方法来处理不同的 HTTP 请求。 2. GenericAPIView\r继承自 APIView，提供了一些通用功能，如分页、过滤和序列化。通常与其他混入类（mixins）一起使用。 3. 视图集（ViewSets）\r视图集是 DRF 中重要的组件，继承自 GenericAPIView，可以方便地处理多种操作。常见的视图集类包括：\nModelViewSet：提供对模型的标准 CRUD 操作。 ReadOnlyModelViewSet：只提供只读操作（如 GET 请求）。 ViewSet：基础视图集类，需手动定义操作。 4. Mixins\r可以与 GenericAPIView 或 ViewSet 结合使用，提供特定的功能。常见的混入类包括： CreateModelMixin：处理创建操作。 RetrieveModelMixin：处理获取单个对象的操作。 UpdateModelMixin：处理更新操作。 DestroyModelMixin：处理删除操作。 ListModelMixin：处理列出对象的操作。 5. 其他类\rDRF 还提供了一些特定功能的视图类，如： APIViewSet：结合了 APIView 的功能。 DocumentationView：用于生成 API 文档。 总结\r通过继承不同的视图类和混入类，开发者可以根据需求灵活地创建和管理 API 视图，实现复杂的业务逻辑和功能。这种组合的方式提高了代码的重用性和可维护性。\n九、简述 django rest framework框架的认证流程\rDjango REST Framework (DRF) 的认证流程涉及用户身份验证的几个主要步骤。以下是简要的认证流程：\n1. 客户端请求\n客户端向 DRF API 发送请求，通常包含用户的认证凭据（如用户名和密码、令牌等）。 2. 认证类\nDRF 使用已配置的认证类来处理请求。认证类可以是： TokenAuthentication：通过发送令牌进行身份验证。 BasicAuthentication：通过基本的用户名和密码进行身份验证。 SessionAuthentication：通过 Django 会话进行身份验证。 JWTAuthentication：通过 JSON Web Token 进行身份验证。 3. 凭据验证\n认证类提取请求中的凭据（如请求头、请求体等），并尝试验证这些凭据： 对于 TokenAuthentication，它会检查提供的令牌是否有效，并查找与该令牌关联的用户。 对于 BasicAuthentication，它会对用户提供的用户名和密码进行验证。 对于 SessionAuthentication，它会检查当前会话是否有效。 4. 设置用户\n如果凭据有效，DRF 会将认证用户设置为 request.user。此时，用户的身份信息可以在后续的请求处理过程中使用。 5. 访问控制\n在处理请求时，DRF 会根据配置的权限类（如 IsAuthenticated, IsAdminUser 等）检查用户的访问权限。如果用户没有访问权限，将返回相应的错误响应（如 403 Forbidden）。 6. 响应结果\n处理完请求后，DRF 会根据用户的身份和权限，返回相应的响应结果。 总结 Django REST Framework 的认证流程通过提取请求中的凭据、验证这些凭据、设置用户身份以及进行访问控制，确保只有授权用户才能访问特定的 API 资源。这一流程为 API 的安全性提供了保障。\n十、django rest framework如何实现的用户访问频率控制\rDjango REST Framework (DRF) 实现用户访问频率控制通常使用以下两种方法：\n1. Django Ratelimit\r使用第三方库 django-ratelimit，可以轻松实现请求频率控制。基本步骤如下： 安装库： 1 pip install django-ratelimit 在视图中应用装饰器： 在需要限制访问频率的视图上使用 @ratelimit 装饰器，示例如下： 1 2 3 4 5 6 7 8 from django_ratelimit.decorators import ratelimit from rest_framework.response import Response from rest_framework.views import APIView class MyAPIView(APIView): @ratelimit(key=\u0026#39;user\u0026#39;, rate=\u0026#39;5/m\u0026#39;, method=\u0026#39;ALL\u0026#39;, block=True) def get(self, request): return Response({\u0026#34;message\u0026#34;: \u0026#34;Success\u0026#34;}) 参数说明： key: 设定限制的依据，可以是用户、IP 等。 rate: 设定访问频率，比如 5/m 表示每分钟最多 5 次请求。 method: 指定限制的方法（如 GET, POST, ALL）。 block: 如果请求超过限制，是否阻止请求。 2. DRF内置的Throttle\rDRF 自带的节流（throttle）机制，通过配置实现请求频率控制。基本步骤如下： 设置节流类： 在 settings.py 中配置节流类和速率： 1 2 3 4 5 6 7 8 9 10 REST_FRAMEWORK = { \u0026#39;DEFAULT_THROTTLE_CLASSES\u0026#39;: [ \u0026#39;rest_framework.throttling.AnonRateThrottle\u0026#39;, # 匿名用户 \u0026#39;rest_framework.throttling.UserRateThrottle\u0026#39;, # 认证用户 ], \u0026#39;DEFAULT_THROTTLE_RATES\u0026#39;: { \u0026#39;anon\u0026#39;: \u0026#39;10/minute\u0026#39;, # 匿名用户每分钟最多 10 次 \u0026#39;user\u0026#39;: \u0026#39;30/minute\u0026#39;, # 认证用户每分钟最多 30 次 } } 应用节流类： 在视图中应用节流类，DRF 会自动根据配置进行控制： 1 2 3 4 5 6 7 8 9 from rest_framework.throttling import UserRateThrottle from rest_framework.views import APIView from rest_framework.response import Response class MyAPIView(APIView): throttle_classes = [UserRateThrottle] def get(self, request): return Response({\u0026#34;message\u0026#34;: \u0026#34;Success\u0026#34;}) 总结\r通过使用 django-ratelimit 或 DRF 自带的节流机制，开发者可以方便地控制用户的访问频率，确保 API 的稳定性和安全性。选择合适的方法取决于具体的需求和场景。\n十一、rest_framework序列化组件的作用,以及一些外键关系的钩子方法\rDjango REST Framework (DRF) 的序列化组件主要用于将复杂数据类型（如 Django 模型实例）转换为可直接用于 JSON 或其他格式的简单数据类型，同时也支持将输入数据转换回模型实例并进行验证。具体作用包括：\n序列化组件的作用\r数据转换：\n将 Django 模型实例或查询集转换为 JSON 等格式，以便通过 API 返回给客户端。 数据验证：\n在将用户输入的数据保存到数据库之前，序列化器可以验证数据的有效性，确保符合预定义的格式和规则。 字段定义：\n允许开发者定义要包含的字段，能够自定义字段的表现和验证规则。 嵌套序列化：\n支持嵌套序列化，允许处理关联模型（如外键、多对多关系等）。 钩子方法：\n提供了多种钩子方法，以便在序列化和反序列化过程中执行自定义逻辑。 外键关系的钩子方法\r在处理外键关系时，序列化器提供了一些常用的钩子方法：\ncreate()：\n用于在反序列化时创建模型实例。可以在此方法中处理外键关系。 1 2 3 4 5 def create(self, validated_data): related_data = validated_data.pop(\u0026#39;related_field\u0026#39;) instance = MyModel.objects.create(**validated_data) RelatedModel.objects.create(my_model=instance, **related_data) return instance update()：\n用于更新模型实例。可以在此方法中处理外键的更新。 1 2 3 4 5 6 7 8 def update(self, instance, validated_data): related_data = validated_data.pop(\u0026#39;related_field\u0026#39;) instance.field_name = validated_data.get(\u0026#39;field_name\u0026#39;, instance.field_name) instance.save() # 更新外键关系 related_instance = instance.related_field related_instance.update(**related_data) return instance to_representation()：\n将模型实例转换为可序列化的数据格式。在这里，可以自定义外键字段的表现。 1 2 3 4 def to_representation(self, instance): representation = super().to_representation(instance) representation[\u0026#39;related_field\u0026#39;] = RelatedSerializer(instance.related_field).data return representation 总结\rDRF 的序列化组件不仅简化了数据的转换和验证过程，还提供了灵活的钩子方法，以便处理复杂的数据关系（如外键），让开发者能够方便地管理和定制 API 的数据流。\nReferences\rpython web框架django面试题 ","date":"2024-10-16T10:36:20+08:00","permalink":"https://leanmax.github.io/p/django%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%94/","title":"Django面试题（五）"},{"content":"一、django内置的缓存机制？\rDjango 提供了一个内置的缓存框架，可以通过多种方式缓存页面、视图、查询结果或其他数据，以提高性能和减少数据库访问。Django 的缓存机制非常灵活，支持多种缓存后端，如内存、文件系统、数据库等。下面是 Django 内置缓存机制的主要部分：\n1. 缓存后端\rDjango 支持多种缓存后端，常见的包括：\n内存缓存（MemoryCache）：使用本地内存作为缓存存储，适合单机部署的小型项目。\n1 2 3 4 5 CACHES = { \u0026#39;default\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.core.cache.backends.locmem.LocMemCache\u0026#39;, } } 文件系统缓存（FileBasedCache）：将缓存存储在文件系统中，适合需要跨进程共享的缓存。\n1 2 3 4 5 6 CACHES = { \u0026#39;default\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.core.cache.backends.filebased.FileBasedCache\u0026#39;, \u0026#39;LOCATION\u0026#39;: \u0026#39;/var/tmp/django_cache\u0026#39;, } } 数据库缓存（DatabaseCache）：将缓存存储在数据库中，需要预先创建缓存表。\n1 2 3 4 5 6 CACHES = { \u0026#39;default\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.core.cache.backends.db.DatabaseCache\u0026#39;, \u0026#39;LOCATION\u0026#39;: \u0026#39;my_cache_table\u0026#39;, } } 创建缓存表：\n1 python manage.py createcachetable Memcached：一个高效的内存缓存系统，适合大规模部署的项目。\n1 2 3 4 5 6 CACHES = { \u0026#39;default\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.core.cache.backends.memcached.MemcachedCache\u0026#39;, \u0026#39;LOCATION\u0026#39;: \u0026#39;127.0.0.1:11211\u0026#39;, } } Redis：流行的键值存储，支持复杂的数据结构，适合高并发项目。\n1 2 3 4 5 6 CACHES = { \u0026#39;default\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django_redis.cache.RedisCache\u0026#39;, \u0026#39;LOCATION\u0026#39;: \u0026#39;redis://127.0.0.1:6379/1\u0026#39;, } } 2. 缓存的使用方式\rDjango 提供了多种级别的缓存控制方式，包括：\n（1）整个网站的缓存\r通过 CACHE_MIDDLEWARE_ALIAS 中间件配置，可以为整个网站启用缓存。\n1 2 3 4 5 6 7 MIDDLEWARE = [ \u0026#39;django.middleware.cache.UpdateCacheMiddleware\u0026#39;, # 在视图执行前缓存页面 # 其他中间件 \u0026#39;django.middleware.cache.FetchCacheMiddleware\u0026#39;, # 从缓存中获取页面 ] CACHE_MIDDLEWARE_SECONDS = 600 # 缓存600秒 CACHE_MIDDLEWARE_ALIAS = \u0026#39;default\u0026#39; # 使用默认的缓存配置 （2）视图级缓存\r你可以为某个视图单独设置缓存，使用 @cache_page 装饰器。\n1 2 3 4 5 6 from django.views.decorators.cache import cache_page @cache_page(60 * 15) # 缓存15分钟 def my_view(request): # 视图逻辑 return render(request, \u0026#39;my_template.html\u0026#39;) （3）模板片段缓存\r对于一些昂贵的计算或数据库查询，你可以缓存模板的某个片段，而不是整个页面。使用 cache 模板标签。\n1 2 3 4 {% load cache %} {% cache 600 sidebar %} \u0026lt;!-- 这里是一些昂贵的查询和模板渲染逻辑 --\u0026gt; {% endcache %} （4）手动缓存控制\r你可以使用 Django 的 cache 模块手动控制缓存的存取。常见操作包括：\n设置缓存：\n1 2 from django.core.cache import cache cache.set(\u0026#39;my_key\u0026#39;, \u0026#39;my_value\u0026#39;, timeout=60) # 缓存60秒 获取缓存：\n1 value = cache.get(\u0026#39;my_key\u0026#39;) 删除缓存：\n1 cache.delete(\u0026#39;my_key\u0026#39;) 检查缓存是否存在：\n1 2 if cache.has_key(\u0026#39;my_key\u0026#39;): # 做某些操作 3. 缓存失效和超时\rTimeout（超时）：你可以为缓存设置超时，当超时到期后，缓存内容会自动失效并删除。通过 timeout 参数设置缓存时长，默认为全局的超时时间，也可以在 set() 方法中单独指定。\nKey-based Invalidations（基于键的失效）：当你需要主动失效缓存时，可以通过 delete() 方法手动删除缓存条目。\n4. 缓存版本控制\rDjango 还支持缓存的版本控制功能，这在你想要统一刷新缓存时很有用。通过 cache.set() 和 cache.get() 的 version 参数可以指定缓存版本。\n5. 基于数据库查询的缓存\rDjango ORM 通过缓存框架可以缓存某些昂贵的数据库查询结果。比如，手动缓存查询结果：\n1 2 3 4 5 # 缓存查询结果 results = cache.get(\u0026#39;my_query\u0026#39;) if not results: results = MyModel.objects.filter(field=\u0026#39;value\u0026#39;) cache.set(\u0026#39;my_query\u0026#39;, results, timeout=300) 6. SESSION 缓存\rDjango 也支持将用户的 session 存储在缓存中，提升 session 的读写性能。\n1 2 SESSION_ENGINE = \u0026#39;django.contrib.sessions.backends.cache\u0026#39; SESSION_CACHE_ALIAS = \u0026#39;default\u0026#39; # 使用默认缓存配置 总结\rDjango 内置缓存框架支持多种缓存后端（内存、文件、数据库、Memcached、Redis等）。 提供了全局、视图、模板片段和手动缓存控制方式。 可以通过信号和钩子函数实现缓存的自动化管理。 缓存超时、失效和版本控制使得缓存机制更加灵活。 二、django的缓存能使用redis吗？如果可以的话，如何配置？\r是的，Django 支持使用 Redis 作为缓存后端。Redis 是一个高性能的键值数据库，广泛用于缓存、消息队列等场景。Django 内置的缓存框架可以轻松配置为使用 Redis 来存储缓存数据。\n配置步骤如下：\r1. 安装依赖包\r首先，你需要安装 django-redis 这个库，它是 Django 使用 Redis 作为缓存后端的常用库。\n1 pip install django-redis 2. 修改 Django 的缓存配置\r在 settings.py 文件中，配置缓存使用 Redis 作为后端。以下是一个常见的 Redis 缓存配置示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 CACHES = { \u0026#39;default\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django_redis.cache.RedisCache\u0026#39;, # 使用django-redis提供的RedisCache后端 \u0026#39;LOCATION\u0026#39;: \u0026#39;redis://127.0.0.1:6379/1\u0026#39;, # Redis的连接地址，IP、端口和数据库编号 \u0026#39;OPTIONS\u0026#39;: { \u0026#39;CLIENT_CLASS\u0026#39;: \u0026#39;django_redis.client.DefaultClient\u0026#39;, # 客户端类 # 其他可选配置，例如序列化器 \u0026#39;SERIALIZER\u0026#39;: \u0026#39;django_redis.serializers.json.JSONSerializer\u0026#39;, # 使用JSON序列化 # \u0026#39;PASSWORD\u0026#39;: \u0026#39;your_redis_password\u0026#39;, # 如果Redis设置了密码，可以在这里添加 }, \u0026#39;TIMEOUT\u0026#39;: 300, # 默认缓存过期时间，单位为秒 \u0026#39;KEY_PREFIX\u0026#39;: \u0026#39;myapp\u0026#39;, # 缓存键的前缀，避免键冲突 } } 配置选项解释：\rBACKEND: 指定缓存后端为 django_redis.cache.RedisCache，这是 django-redis 提供的缓存后端。 LOCATION: 指定 Redis 的连接地址，例如 redis://127.0.0.1:6379/1 表示连接到本地的 Redis，使用数据库编号 1。 OPTIONS: CLIENT_CLASS: 使用 django_redis.client.DefaultClient 来处理 Redis 的客户端连接。 SERIALIZER: 指定序列化器，例如这里使用 JSON 序列化器。默认情况下使用 pickle 序列化器。 PASSWORD: 如果 Redis 服务器设置了密码，可以在此指定密码。 TIMEOUT: 设置缓存过期时间（单位：秒），可以根据需求调整。 KEY_PREFIX: 在 Redis 缓存的键名之前加上前缀，防止不同项目间的缓存键冲突。 3. 测试 Redis 缓存\r你可以在项目中测试缓存是否正常工作，例如：\n1 2 3 4 5 6 7 8 from django.core.cache import cache # 设置缓存 cache.set(\u0026#39;my_key\u0026#39;, \u0026#39;my_value\u0026#39;, timeout=60) # 缓存60秒 # 获取缓存 value = cache.get(\u0026#39;my_key\u0026#39;) print(value) # 输出：my_value 如果配置正确，Redis 将开始存储和管理缓存数据。你可以使用 Redis CLI 工具查看缓存的键值：\n1 redis-cli 在 Redis CLI 中，执行 KEYS * 查看 Redis 中所有的缓存键。\n4. 额外选项\r集群：如果你使用的是 Redis 集群，可以使用 django_redis.client.HerdClient 或 ShardedClient 作为 CLIENT_CLASS。\n持久化连接：可以通过 OPTIONS 配置持久化连接来提升性能，例如：\n1 2 3 4 \u0026#39;OPTIONS\u0026#39;: { \u0026#39;CONNECTION_POOL_KWARGS\u0026#39;: {\u0026#39;max_connections\u0026#39;: 100}, \u0026#39;CONNECTION_TIMEOUT\u0026#39;: 20, } 5. Session 缓存\r你也可以将用户会话存储在 Redis 中，提高会话读写性能。配置如下：\n1 2 SESSION_ENGINE = \u0026#39;django.contrib.sessions.backends.cache\u0026#39; SESSION_CACHE_ALIAS = \u0026#39;default\u0026#39; # 使用上面配置的Redis缓存 总结\r通过 django-redis 库，Django 能够轻松使用 Redis 作为缓存后端。只需在 settings.py 中配置 CACHES 变量，并确保安装了 django-redis 和 redis 服务器。\n三、django的模板中filter和simple_tag的区别？\r在 Django 的模板系统中，filter 和 simple_tag 都是用于扩展模板语言功能的模板标签，但它们的功能和用途有所不同。下面对它们的区别进行详细说明：\n1. filter（过滤器）\r用途：用于对模板变量进行简单的处理或转换，类似于 Unix 命令中的管道符。过滤器通常接收一个输入值，对其进行转换，并返回结果。过滤器是最常用于对单一值进行修改或格式化的工具。 输入：通常只接收一个模板变量作为输入，部分过滤器还支持传递一个额外的参数。 使用场景：过滤字符串、列表、数字等简单数据类型，常用于字符串格式化、数据转换等操作。 例子：\r1 {{ \u0026#34;hello world\u0026#34;|upper }} 上面的例子会将字符串 \u0026quot;hello world\u0026quot; 转换为大写字母，结果为 \u0026quot;HELLO WORLD\u0026quot;。\n创建自定义过滤器：\r你可以通过 @register.filter 来定义自定义的过滤器。例如，创建一个将字符串反转的过滤器：\n1 2 3 4 5 6 7 from django import template register = template.Library() @register.filter def reverse_string(value): return value[::-1] 在模板中使用自定义过滤器：\n1 {{ \u0026#34;hello\u0026#34;|reverse_string }} # 输出: \u0026#34;olleh\u0026#34; 2. simple_tag（简单标签）\r用途：simple_tag 是 Django 模板标签中更强大的工具，用于执行复杂的逻辑、操作多个参数，甚至可以处理和返回动态内容。相比于过滤器，它的功能更加灵活。 输入：可以接收多个参数，甚至关键字参数，允许返回任何内容（字符串、HTML 片段、变量等）。 使用场景：当需要在模板中进行更复杂的处理，或者需要返回动态数据时使用，如渲染动态 HTML、获取模型数据等。 例子：\r1 2 3 4 5 6 7 from django import template register = template.Library() @register.simple_tag def greet(name): return f\u0026#34;Hello, {name}!\u0026#34; 在模板中使用这个标签：\n1 {% greet \u0026#34;Django\u0026#34; %} # 输出: Hello, Django! 创建自定义 simple_tag：\rsimple_tag 比过滤器更适合需要多参数或者处理更复杂逻辑的场景。例如，创建一个自定义标签来计算两个数的乘积：\n1 2 3 4 5 6 7 from django import template register = template.Library() @register.simple_tag def multiply(a, b): return a * b 在模板中使用：\n1 {% multiply 3 5 %} # 输出: 15 3. 总结对比\r功能 过滤器（filter） 简单标签（simple_tag） 使用场景 对模板变量进行简单转换或格式化 需要执行复杂逻辑、处理多个参数或返回动态数据 输入 接收一个输入值，可选传递一个参数 支持多个参数，包括关键字参数 返回值 只能返回处理后的结果值 可以返回字符串、HTML、任何复杂数据 复杂性 适合简单数据处理 适合复杂逻辑和动态内容生成 定义方式 @register.filter @register.simple_tag 典型用例 字符串处理、格式化、数据转换等简单任务 处理多参数、动态生成内容、复杂业务逻辑等 4. 何时使用\r使用 filter：当你只需要对模板变量做简单操作（如字符串操作、数据转换）时，使用过滤器最合适。 使用 simple_tag：当你需要在模板中执行较复杂的业务逻辑、操作多个参数、或返回动态内容时，应该选择 simple_tag。 四、django-debug-toolbar的作用？\rDjango-debug-toolbar是一个开源的第三方Django应用程序，为开发人员提供了许多实用的调试工具。以下是Django-debug-toolbar的主要作用：\n性能调优：Django-debug-toolbar可以显示关于页面生成的所有SQL查询，包括每个查询所用的时间。这有助于开发人员轻松检测到潜在的性能问题和瓶颈，并提供了一些解决这些问题的方法。此外，它还可以报告缓存性能和模板呈现时间，帮助开发人员优化应用程序的性能。 系统调试：Django-debug-toolbar提供了一个可扩展的面板系统，支持对SQL查询、CORS请求、邀请码等功能的调试。它还可以显示调试概览、请求和响应头等信息，帮助开发人员深入了解代码正在做什么以及花费了多少时间。 总的来说，Django-debug-toolbar是一个方便的工具，可以帮助Django开发人员更好地理解和优化他们的应用程序。请注意，使用Django-debug-toolbar时，应确保只在开发环境中使用，避免在生产环境中暴露敏感信息。 五、django中如何实现单元测试？\r在Django中实现单元测试主要依赖于Django自带的测试框架，它提供了一系列工具和约定来帮助你编写和执行测试。以下是在Django中实现单元测试的基本步骤：\n创建测试文件：在Django应用中，通常会在应用的tests.py文件中编写单元测试。如果该文件不存在，你需要创建一个。你也可以为不同的功能或模型创建多个测试文件，只需确保它们以test_开头，这样Django的测试运行器就能自动发现它们。 编写测试类：在测试文件中，你需要定义一个或多个测试类。每个测试类应该继承自django.test.TestCase，这个类提供了很多用于测试Django应用的工具和方法。 编写测试方法：在测试类中，你可以定义多个以test_开头的方法来编写具体的测试用例。每个测试方法都应该测试应用的一个特定方面或功能。 使用Django测试客户端：Django提供了一个测试客户端，可以用来模拟用户请求并检查应用的响应。你可以在测试方法中使用这个客户端来发送GET、POST等请求，并检查返回的响应内容、状态码等。 使用断言：在测试方法中，你需要使用断言来验证应用的行为是否符合预期。Django的TestCase类提供了很多断言方法，比如assertEqual、assertTrue等，可以用来比较值、检查条件等。 运行测试：在命令行中，你可以使用python manage.py test命令来运行测试。Django会自动发现并执行所有以test_开头的测试方法和类。 以下是一个简单的Django单元测试示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 from django.test import TestCase from .models import MyModel class MyModelTests(TestCase): def test_create_my_model(self): # 创建一个实例并保存到数据库中 MyModel.objects.create(name=\u0026#39;Test Name\u0026#39;) # 从数据库中获取该实例 my_model = MyModel.objects.get(name=\u0026#39;Test Name\u0026#39;) # 验证实例的名称属性是否正确 self.assertEqual(my_model.name, \u0026#39;Test Name\u0026#39;) 在实际项目中，你可能会编写更多的测试用例来覆盖应用的各个方面，并使用更复杂的断言来验证应用的行为。此外，Django还提供了很多其他的测试工具和功能，比如fixtures、transaction management等，可以帮助你更好地进行测试。\n六、Django如何实现websocket？\rDjango本身并不直接支持WebSocket，但你可以通过第三方库如channels来为Django添加WebSocket功能。channels库是一个为Django提供实时、双向通信能力的库，它扩展了Django的视图和URL路由系统来处理WebSocket、HTTP2和其他协议。\n下面是一个简单的步骤，展示如何使用channels在Django中实现WebSocket：\n安装channels库： 首先，你需要安装channels库。你可以使用pip来安装： 1 pip install channels 另外，channels通常需要与channels_redis或daphne/uvicorn等一起使用，作为消息传递的后端或ASGI服务器。\n1 pip install channels_redis 或者如果你想使用daphne作为ASGI服务器：\n1 pip install daphne 配置Django项目： 修改你的Django项目的settings.py文件来添加channels的配置。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 INSTALLED_APPS = [ # ... 其他应用 \u0026#39;channels\u0026#39;, ] ASGI_APPLICATION = \u0026#39;\u0026lt;your_project_name\u0026gt;.asgi.application\u0026#39; # Channels配置 CHANNEL_LAYERS = { \u0026#39;default\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;channels_redis.core.RedisChannelLayer\u0026#39;, \u0026#39;CONFIG\u0026#39;: { \u0026#39;hosts\u0026#39;: [(\u0026#39;127.0.0.1\u0026#39;, 6379)], }, }, } 创建ASGI应用： 在你的Django项目根目录下，创建一个名为asgi.py的文件，内容大致如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import os from django.core.asgi import get_asgi_application from channels.routing import ProtocolTypeRouter, URLRouter from channels.auth import AuthMiddlewareStack import \u0026lt;your_app_name\u0026gt;.routing os.environ.setdefault(\u0026#39;DJANGO_SETTINGS_MODULE\u0026#39;, \u0026#39;\u0026lt;your_project_name\u0026gt;.settings\u0026#39;) application = ProtocolTypeRouter({ \u0026#34;http\u0026#34;: get_asgi_application(), \u0026#34;websocket\u0026#34;: AuthMiddlewareStack( URLRouter( \u0026lt;your_app_name\u0026gt;.routing.websocket_urlpatterns ) ), }) 请确保将\u0026lt;your_project_name\u0026gt;和\u0026lt;your_app_name\u0026gt;替换成你的项目名和应用名。\n定义WebSocket路由： 在你的Django应用目录下，创建一个名为routing.py的文件，并在其中定义你的WebSocket路由。 1 2 3 4 5 6 from django.urls import re_path from . import consumers websocket_urlpatterns = [ re_path(r\u0026#39;ws/some_endpoint/\u0026#39;, consumers.SomeConsumer.as_asgi()), ] 创建WebSocket消费者： 在你的Django应用目录下，创建一个名为consumers.py的文件，并在其中定义WebSocket消费者。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from channels.generic.websocket import AsyncWebsocketConsumer class SomeConsumer(AsyncWebsocketConsumer): async def connect(self): await self.accept() async def disconnect(self, close_code): pass async def receive(self, text_data): # 处理接收到的消息 pass async def send_message(self, message): # 发送消息到WebSocket await self.send(message) 注意：上面的消费者类是基于异步的，如果你想要使用同步代码，你应该从WebsocketConsumer而不是AsyncWebsocketConsumer继承，并相应地调整你的方法。 6. 运行你的WebSocket服务器： 你可以使用daphne或uvicorn来运行你的ASGI应用。 使用daphne：\n1 daphne \u0026lt;your_project_name\u0026gt;.asgi:application 或使用uvicorn（需要先安装uvicorn）：\n1 uvicorn \u0026lt;your_project_name\u0026gt;.asgi:application --port 8000 --protocol websockets 注意：确保将\u0026lt;your_project_name\u0026gt;替换成你的Django项目名。\n现在，你的Django项目应该已经配置好了WebSocket支持，你可以通过客户端连接到WebSocket端点并与服务器进行实时通信了。\nReferences\rpython web框架django面试题 ","date":"2024-10-15T17:48:09+08:00","permalink":"https://leanmax.github.io/p/django%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9B%9B/","title":"Django面试题（四）"},{"content":"django的Form和ModeForm的作用？\rDjango的Form和ModelForm是框架中非常重要的两个组件，主要用于处理表单数据和数据模型。以下是它们的具体作用：\n1. Django Form：\r生成页面可用的HTML标签：Form类可以自动生成HTML表单代码，使得在前端页面中能够方便地展示表单。 **对用户提交的数据进行校验：**Form类可以对用户提交的数据进行各种验证，确保数据的合法性和正确性。这可以防止恶意用户提交非法数据或进行攻击。 保留上次输入内容：如果用户提交的数据验证不通过，Form类可以保留用户上次输入的内容，方便用户进行修改后再次提交。 2. Django ModelForm：\r继承自Form类：ModelForm是Form的子类，因此它具有Form类的所有功能，包括生成HTML标签、数据验证等。 与数据模型进行绑定：ModelForm与Django的数据模型进行绑定，可以直接对数据库表进行操作。这使得在表单处理过程中，可以方便地读取、修改、删除数据库中的数据。 自动生成表单字段：根据绑定的数据模型，ModelForm可以自动生成对应的表单字段，无需手动定义。这大大简化了表单的开发过程。 django的Form组件中,如果字段中包含choices参数，请使用两种方式实现数据源实时更新。\r1. 重写Form类的__init__方法\r可以通过重写Form类的__init__方法来动态地设置字段的choices。这通常涉及到从数据库或其他外部源获取数据，并将其作为字段选项。\n1 2 3 4 5 6 7 8 9 10 11 12 from django import forms from .models import MyModel class MyForm(forms.Form): my_field = forms.ChoiceField(choices=[]) # 初始为空，稍后在__init__中填充 def __init__(self, *args, **kwargs): super(MyForm, self).__init__(*args, **kwargs) # 从数据库或其他地方获取数据 choices = MyModel.objects.values_list(\u0026#39;id\u0026#39;, \u0026#39;name\u0026#39;) # 更新字段的choices self.fields[\u0026#39;my_field\u0026#39;].choices = choices 2. 使用ModelChoiceField\r如果你的选项来自于一个Django模型，你可以使用ModelChoiceField，它允许你指定一个查询集（QuerySet）作为选项。你可以在Form类中定义一个方法来返回查询集，并在ModelChoiceField中使用这个方法。\n1 2 3 4 5 6 7 8 9 10 11 12 from django import forms from .models import MyModel class MyForm(forms.Form): def get_my_choices(): # 返回查询集 return MyModel.objects.all() my_field = forms.ModelChoiceField(queryset=get_my_choices()) # 注意：上面的代码片段有一个问题，即`get_my_choices`在类定义时被调用，而不是在实例化时。 # 正确的做法是使用lambda表达式或者将查询集定义在__init__方法中。 然而，上面的代码片段有一个问题：get_my_choices在类定义时就被调用了，而不是在实例化时。这会导致每次服务器启动时获取一次选项，而不是每次请求时。为了解决这个问题，你应该在__init__方法中设置查询集：\n1 2 3 4 5 6 7 8 9 10 from django import forms from .models import MyModel class MyForm(forms.Form): my_field = forms.ModelChoiceField(queryset=MyModel.objects.none()) # 初始设置为空的查询集 def __init__(self, *args, **kwargs): super(MyForm, self).__init__(*args, **kwargs) # 在实例化时更新查询集 self.fields[\u0026#39;my_field\u0026#39;].queryset = MyModel.objects.all() 在这个修正后的例子中，MyModel.objects.none()创建了一个空的查询集，它在数据库中没有匹配任何记录。然后，在__init__方法中，我们根据实际需要更新了查询集。\n推荐使用第二种方式，因为它直接与Django的ORM集成，可以更容易地处理数据库查询和相关的优化。同时，确保在__init__方法中设置或更新查询集，以确保每次表单实例化时都能获取到最新的数据。\ndjango的Model中的ForeignKey字段中的on_delete参数有什么作用？\r在 Django 的 Model 中，ForeignKey 字段的 on_delete 参数用于指定当关联的外键对象被删除时，当前对象应该如何处理。这是为了确保在外键引用被删除时，数据库的完整性得到维护。\n常见的 on_delete 行为选项\r以下是 on_delete 参数的几种常见选项，它们对应不同的处理方式：\nCASCADE：\n行为：级联删除。当外键关联的对象被删除时，所有引用该对象的记录也会被删除。 使用场景：适用于依赖外键对象存在的子对象。比如：订单删除时，同时删除所有相关的订单明细。 示例： 1 2 3 4 5 6 class Author(models.Model): name = models.CharField(max_length=100) class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, on_delete=models.CASCADE) 如果某个 Author 被删除，那么所有与该 Author 相关联的 Book 记录也会被删除。 PROTECT：\n行为：阻止删除。当尝试删除外键对象时，抛出 ProtectedError 异常，从而阻止删除操作。 使用场景：适用于你希望确保外键引用的对象不会被删除，除非先删除所有相关的依赖对象。 示例： 1 2 3 class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, on_delete=models.PROTECT) 如果某个 Author 关联了 Book，试图删除该 Author 会抛出异常，阻止删除操作。 SET_NULL：\n行为：将外键字段设置为 NULL。需要指定 null=True，否则会引发错误。 使用场景：当外键对象被删除时，当前对象的外键字段可以为空，保持记录存在但移除外键关联。 示例： 1 2 3 class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, on_delete=models.SET_NULL, null=True) 如果某个 Author 被删除，相关的 Book 记录不会被删除，但 author 字段会被设置为 NULL。 SET_DEFAULT：\n行为：将外键字段设置为默认值。需要设置 default 参数。 使用场景：当外键对象被删除时，当前对象的外键字段被重置为一个默认值。 示例： 1 2 3 class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, on_delete=models.SET_DEFAULT, default=1) 如果某个 Author 被删除，相关的 Book 的 author 字段会被设置为默认值（比如 id=1 的 Author）。 SET()：\n行为：调用传入的函数或指定的值来设置外键字段。可以自定义字段的设置行为。 使用场景：适用于复杂的场景，当你需要更灵活的方式来处理删除外键时的字段设置。 示例： 1 2 3 class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, on_delete=models.SET(some_function)) 当 Author 被删除时，some_function 会被调用来设置 author 字段。 DO_NOTHING：\n行为：不做任何处理。Django 不会干预，但可能会违反数据库的外键约束，导致数据库层抛出错误。 使用场景：适用于你在数据库层面手动处理删除外键的逻辑。 示例： 1 2 3 class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, on_delete=models.DO_NOTHING) 如果 Author 被删除，Book 不会有任何变化，但如果数据库有外键约束，可能会抛出错误。 选择合适的 on_delete 选项\r级联删除 (CASCADE)：适合父子关系，删除父对象时自动删除所有子对象。 阻止删除 (PROTECT)：适合不允许删除父对象的场景。 设置为 NULL (SET_NULL)：适合允许子对象存在但取消外键关系的场景。 设置为默认值 (SET_DEFAULT)：适合需要重置外键字段为默认值的情况。 自定义设置 (SET())：适合需要灵活控制字段的更新逻辑时。 不做处理 (DO_NOTHING)：适合手动控制外键删除逻辑，通常需要自己处理异常。 总结\ron_delete 参数为你提供了多种处理外键删除的方式。选择合适的方式取决于你希望当外键对象被删除时，数据库中的相关数据如何处理，从而确保数据的完整性和业务逻辑的正确性。\n列举django orm中三种能写sql语句的方法。\r在 Django ORM 中，虽然 ORM 提供了高级的查询接口，但有时需要直接执行 SQL 语句。Django 提供了三种常见的方式可以编写和执行 SQL 语句：\n1. raw() 方法\r描述：用于执行原生 SQL 查询，并返回模型实例。可以将原生 SQL 语句与 Django 模型结合使用。\n适用场景：适用于复杂的查询或无法通过 ORM 生成的 SQL 查询。\n示例：\n1 2 3 4 5 6 7 8 class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, on_delete=models.CASCADE) # 使用 raw() 执行原生 SQL 查询 books = Book.objects.raw(\u0026#39;SELECT * FROM myapp_book WHERE author_id = %s\u0026#39;, [1]) for book in books: print(book.title) 注意：raw() 返回的对象是模型实例，但不能使用 raw() 来进行插入、更新或删除操作。\n2. Manager.raw() 方法\r描述：从模型管理器执行原生 SQL 查询。类似于 raw()，但是在模型的 Manager 上调用，返回查询结果集。 适用场景：当你想在模型管理器中定义自定义查询时使用（可用作默认查询）。 示例： 1 2 3 4 5 6 7 8 9 10 11 12 class BookManager(models.Manager): def with_custom_sql(self): return self.raw(\u0026#39;SELECT * FROM myapp_book WHERE title LIKE %s\u0026#39;, [\u0026#39;%Django%\u0026#39;]) class Book(models.Model): title = models.CharField(max_length=100) objects = BookManager() # 使用自定义的 Manager 来执行 SQL 查询 books = Book.objects.with_custom_sql() for book in books: print(book.title) 3. connection.cursor() 方法\r描述：直接使用数据库游标执行任意 SQL 语句。可以执行 SELECT、INSERT、UPDATE、DELETE 等操作，返回结果集或影响的行数。\n适用场景：适合需要执行任意 SQL 语句，或者执行不返回模型实例的操作（如批量插入、更新、删除等）。\n示例：\n1 2 3 4 5 6 7 8 9 from django.db import connection # 使用 cursor() 执行自定义 SQL 语句 with connection.cursor() as cursor: cursor.execute(\u0026#39;SELECT * FROM myapp_book WHERE author_id = %s\u0026#39;, [1]) rows = cursor.fetchall() # 返回所有查询结果 for row in rows: print(row) 注意：cursor() 提供了直接操作数据库的能力，但需要手动处理返回的数据，查询结果不会映射为模型实例。\n总结表格\r方法 作用 场景 示例 raw() 执行原生 SQL 并返回模型实例 查询复杂的或无法通过 ORM 实现的查询 Book.objects.raw('SELECT * FROM myapp_book') Manager.raw() 在模型管理器中自定义查询 自定义模型管理器中的复杂 SQL 查询 Book.objects.with_custom_sql() connection.cursor() 使用游标执行任意 SQL 执行任意 SQL（包括查询、插入、更新、删除等操作） cursor.execute('SELECT * FROM myapp_book') 这三种方式允许开发者根据需求灵活执行原生 SQL 语句，尤其是在 ORM 难以实现或性能要求较高的场景下，显得尤为重要。\ndjango orm 中如何设置读写分离？\r在 Django 中实现读写分离（即将读操作与写操作分离到不同的数据库实例）通常通过配置多个数据库、并根据操作类型（读或写）路由请求到相应的数据库。Django 的数据库路由机制允许开发者自定义逻辑来决定某个查询应该发送到哪个数据库。\n实现读写分离的步骤\r配置多个数据库\n在 settings.py 文件中配置多个数据库。通常，一个主数据库用于写操作（default），一个或多个从数据库用于读操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.postgresql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;main_db\u0026#39;, \u0026#39;USER\u0026#39;: \u0026#39;db_user\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;password\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;main_db_host\u0026#39;, \u0026#39;PORT\u0026#39;: \u0026#39;5432\u0026#39;, }, \u0026#39;replica\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.postgresql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;replica_db\u0026#39;, \u0026#39;USER\u0026#39;: \u0026#39;db_user\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;password\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;replica_db_host\u0026#39;, \u0026#39;PORT\u0026#39;: \u0026#39;5432\u0026#39;, }, } 自定义数据库路由\n使用数据库路由来确定读请求（SELECT）应该发送到从数据库，而写请求（INSERT、UPDATE、DELETE）发送到主数据库。通过创建一个自定义路由器类来实现该逻辑。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class DatabaseRouter: \u0026#34;\u0026#34;\u0026#34; A router to control all database operations on models. \u0026#34;\u0026#34;\u0026#34; def db_for_read(self, model, **hints): \u0026#34;\u0026#34;\u0026#34; Attempts to read go to the replica. \u0026#34;\u0026#34;\u0026#34; return \u0026#39;replica\u0026#39; # 所有读操作都路由到从数据库 def db_for_write(self, model, **hints): \u0026#34;\u0026#34;\u0026#34; Attempts to write go to the default database. \u0026#34;\u0026#34;\u0026#34; return \u0026#39;default\u0026#39; # 所有写操作都路由到主数据库 def allow_relation(self, obj1, obj2, **hints): \u0026#34;\u0026#34;\u0026#34; Allow relations if a model in the default or replica database is involved. \u0026#34;\u0026#34;\u0026#34; db_list = (\u0026#39;default\u0026#39;, \u0026#39;replica\u0026#39;) if obj1._state.db in db_list and obj2._state.db in db_list: return True return None def allow_migrate(self, db, app_label, model_name=None, **hints): \u0026#34;\u0026#34;\u0026#34; Ensure that all models end up in the default database. \u0026#34;\u0026#34;\u0026#34; return db == \u0026#39;default\u0026#39; # 迁移只在主数据库上进行 然后，在 settings.py 中注册该路由器。 1 DATABASE_ROUTERS = [\u0026#39;path.to.DatabaseRouter\u0026#39;] 选择性地使用数据库\nDjango ORM 默认使用路由规则来决定数据库，但在某些情况下，开发者可能想显式指定使用哪个数据库。可以通过 using() 方法选择数据库。 1 2 3 4 5 6 # 从数据库中读取 books = Book.objects.using(\u0026#39;replica\u0026#39;).all() # 向主数据库中写入 new_book = Book(title=\u0026#34;Django Tips\u0026#34;) new_book.save(using=\u0026#39;default\u0026#39;) 读写事务管理\n在使用多个数据库时，需要确保事务是按照操作类型在正确的数据库上进行。例如，读事务应该发生在从库，写事务应该发生在主库。 1 2 3 4 5 6 7 8 9 from django.db import transaction # 在主数据库上执行写操作 with transaction.atomic(using=\u0026#39;default\u0026#39;): Book.objects.create(title=\u0026#34;New Book\u0026#34;) # 在从数据库上执行读操作 with transaction.atomic(using=\u0026#39;replica\u0026#39;): books = Book.objects.all() 多数据库一致性问题\n在读写分离的架构中，由于主从复制的延迟，可能存在主库写入的数据还未同步到从库的情况。这时，从库的读操作可能读不到最新的数据。 解决方案之一是使用某种机制确保特定情况下（如立即读取刚刚写入的数据）从主库读取，或者通过更复杂的路由逻辑来处理这些场景。 小结\r通过配置多个数据库并自定义数据库路由，Django 可以实现读写分离。读操作通常路由到从库，而写操作路由到主库，从而分散数据库负载并提高系统的可扩展性。在实现读写分离时，需要注意主从数据库的同步延迟问题，并根据实际应用场景调整数据库路由的逻辑。\ndjango中如何实现orm表中添加数据时创建一条日志记录。\r在 Django 中，你可以通过多种方式在 ORM 表中添加数据时创建一条日志记录。一个常见的解决方案是使用 Django 的信号 或 重写模型的 save() 方法，在数据创建或更新时自动记录日志。\n方案 1：使用 Django 信号 (signals)\rDjango 提供了 signals，你可以监听模型的 post_save 信号来在数据保存后记录日志。\n步骤\r定义信号处理器： 你可以定义一个信号处理器，在模型保存时触发日志记录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from django.db.models.signals import post_save from django.dispatch import receiver import logging from .models import MyModel # 导入你的模型 # 设置日志记录器 logger = logging.getLogger(__name__) @receiver(post_save, sender=MyModel) def log_model_save(sender, instance, created, **kwargs): if created: logger.info(f\u0026#39;New record created: {instance}\u0026#39;) else: logger.info(f\u0026#39;Record updated: {instance}\u0026#39;) 连接信号： 在应用的 apps.py 中连接信号，确保应用启动时加载信号处理器。\n1 2 3 4 5 6 7 from django.apps import AppConfig class MyAppConfig(AppConfig): name = \u0026#39;myapp\u0026#39; def ready(self): import myapp.signals # 确保 signals.py 文件被加载 配置日志： 确保你的 Django 项目中已经正确配置了日志功能，通常是在 settings.py 中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 LOGGING = { \u0026#39;version\u0026#39;: 1, \u0026#39;disable_existing_loggers\u0026#39;: False, \u0026#39;handlers\u0026#39;: { \u0026#39;console\u0026#39;: { \u0026#39;class\u0026#39;: \u0026#39;logging.StreamHandler\u0026#39;, }, }, \u0026#39;loggers\u0026#39;: { \u0026#39;django\u0026#39;: { \u0026#39;handlers\u0026#39;: [\u0026#39;console\u0026#39;], \u0026#39;level\u0026#39;: \u0026#39;INFO\u0026#39;, }, \u0026#39;myapp\u0026#39;: { \u0026#39;handlers\u0026#39;: [\u0026#39;console\u0026#39;], \u0026#39;level\u0026#39;: \u0026#39;INFO\u0026#39;, \u0026#39;propagate\u0026#39;: False, }, }, } 效果： 当你在数据库中创建或更新 MyModel 的实例时，Django 会自动在日志中记录一条新创建或更新的消息。\n方案 2：重写模型的 save() 方法\r另一种方式是直接在模型的 save() 方法中加入日志记录逻辑，每次调用 save() 时记录日志。\n步骤\r重写模型的 save() 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import logging from django.db import models logger = logging.getLogger(__name__) class MyModel(models.Model): name = models.CharField(max_length=100) description = models.TextField() def save(self, *args, **kwargs): # 判断是创建还是更新 if self.pk is None: logger.info(f\u0026#39;Creating new record: {self}\u0026#39;) else: logger.info(f\u0026#39;Updating record: {self}\u0026#39;) # 调用父类的 save 方法，确保数据保存 super(MyModel, self).save(*args, **kwargs) 效果：\n在每次保存时，save() 方法都会被调用。日志记录器会自动判断当前操作是创建新记录还是更新已有记录，并相应地写入日志。 方案 3：使用数据库表记录日志\r如果你希望将日志存储在数据库中，而不是日志文件中，你可以创建一个日志模型，手动在 save() 方法或信号中记录每次操作的详细信息。\n步骤\r创建日志模型：\n1 2 3 4 5 6 7 8 9 10 11 from django.db import models class LogEntry(models.Model): action = models.CharField(max_length=100) model_name = models.CharField(max_length=100) object_id = models.IntegerField() timestamp = models.DateTimeField(auto_now_add=True) details = models.TextField() def __str__(self): return f\u0026#39;{self.action} on {self.model_name} (ID: {self.object_id}) at {self.timestamp}\u0026#39; 在 save() 方法中创建日志记录：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MyModel(models.Model): name = models.CharField(max_length=100) description = models.TextField() def save(self, *args, **kwargs): # 判断创建还是更新 action = \u0026#39;Created\u0026#39; if self.pk is None else \u0026#39;Updated\u0026#39; super(MyModel, self).save(*args, **kwargs) # 保存模型数据 # 创建日志记录 LogEntry.objects.create( action=action, model_name=self.__class__.__name__, object_id=self.pk, details=f\u0026#39;{action} record: {self}\u0026#39; ) 效果：\n每次模型保存时，日志模型会保存一条记录，记录操作类型（创建或更新）、模型名称、对象 ID 以及详细信息。 总结\r使用 Django 信号：适合解耦逻辑的方式，不需要修改模型类代码，可以针对所有模型统一记录日志。 重写 save() 方法：直接在模型中控制日志记录，简单且有效，适合某些特定模型的日志需求。 数据库日志：如果希望在数据库中保存操作日志，使用一个日志模型可以轻松管理所有记录。 你可以根据实际需求选择合适的方法来实现 Django ORM 表数据变更时的日志记录。\n解释orm中 db first 和 code first的含义？\r在ORM（Object Relational Mapping，对象关系映射）中，“db first”和“code first”是两种开发模式，用于处理数据库和应用程序代码之间的关系。\ndb first（数据库优先）：\r含义：这种模式首先从设计数据库开始。开发者会先创建数据库，包括定义表、字段、关系等，然后使用ORM工具根据已存在的数据库结构生成相应的数据模型类。这种方式的好处是数据库设计可以独立于应用程序代码，数据库管理员（DBA）可以专注于优化数据库性能，而开发者可以专注于编写应用程序逻辑。 应用：适用于那些数据库已经存在，且需要在其上构建应用程序的场景。例如，企业可能已经有了一个经过优化的数据库，现在需要开发一个新的Web应用程序来访问这个数据库。 code first（代码优先）：\r含义：与“db first”相反，“code first”模式强调从编写代码开始。开发者首先定义数据模型类（通常是C#、Java等语言的类），然后使用ORM工具根据这些类自动生成数据库结构。这种方式的好处是开发者可以专注于编写面向对象的代码，而不需要过多关注数据库的具体实现细节。ORM工具会自动处理数据库结构的创建和更新。 应用：适用于从零开始开发应用程序，且需要快速迭代和灵活调整数据库结构的场景。例如，初创公司可能需要快速开发一个MVP（最小可行产品），并根据用户反馈不断调整数据库结构。 在实际开发中，选择“db first”还是“code first”取决于具体需求和团队偏好。有些项目可能会混合使用这两种模式，以获得最佳的开发效率和数据库性能。\n使用orm和原生sql的优缺点？\r类别 优点 缺点 ORM 简化开发流程：ORM框架使得开发者无需编写复杂的SQL语句，从而简化了开发流程。\n提高代码可读性：ORM框架隐藏了底层数据库的实现细节，使得代码更加清晰易懂。\n易用性：可以有效减少重复SQL，提供了基础的CRUD操作、多表关联查询、事务控制、钩子函数等功能。\n移植性好：ORM框架可以轻松地切换不同的数据库，而无需修改大量的SQL语句。 学习成本高：需要掌握ORM框架的API和概念，有一定的学习成本。\n可能影响查询性能：ORM框架在查询数据时可能会产生额外的开销，导致查询性能下降。\n复杂数据模型处理有限：对于复杂的数据模型，ORM框架的性能和可靠性可能受到限制。\n原生SQL 灵活性：原生SQL提供了灵活的查询语法，可以精确控制数据访问，满足各种复杂查询需求。\n性能优势：对于大量数据的处理，原生SQL的性能通常优于ORM框架。\n直接操作数据库：原生SQL可以直接操作数据库，避免ORM框架可能产生的额外开销。 编写和维护成本高：需要手写SQL语句，并对其进行维护，有一定的编写和维护成本。\n数据库依赖性：SQL语句通常针对特定的数据库编写，切换数据库时需要修改SQL语句。\n代码可读性差：相比ORM框架，原生SQL的代码可读性较差，不易于理解和维护。 django中如何根据数据库表生成model中的类？\r在Django中，如果你已经有一个存在的数据库，并且想要根据数据库中的表来生成Django模型（model）类，你可以使用inspectdb命令。这个命令可以自动为你生成一个模型类的代码，该代码基于你的数据库表结构。\n以下是如何使用inspectdb的步骤：\n打开命令行工具（例如Terminal或Command Prompt）。 切换到你的Django项目目录。 运行以下命令： 1 python manage.py inspectdb \u0026gt; app_name/models.py 这里的app_name应该替换成你想要在其中创建模型的应用程序的名称。注意，这个命令会将生成的代码直接输出到标准输出（stdout），所以我们使用\u0026gt;重定向符号将其保存到models.py文件中。\n然而，直接重定向输出到models.py可能会覆盖你现有的文件内容。如果你不希望这样，你可以先将输出重定向到一个临时文件，然后手动将生成的代码复制到你的models.py文件中。\n更好的做法是使用以下命令将输出重定向到一个新的文件中：\n1 python manage.py inspectdb \u0026gt; app_name/models_from_db.py 然后，你可以打开models_from_db.py文件，将生成的模型类复制并粘贴到你的models.py文件中。 4. 打开models.py（或models_from_db.py，如果你选择了上面的第二种方法），检查并修改生成的模型类。通常，你需要做一些调整以适应Django的命名约定和你的项目需求。 5. 在你的Django应用的admin.py文件中注册这些模型，如果你想要通过Django管理界面来管理它们的话。 6. 运行python manage.py makemigrations和python manage.py migrate来创建和应用迁移，虽然这些模型是基于现有数据库表生成的，但这一步通常是不必要的，除非你计划对这些模型进行进一步的修改。\n请注意，inspectdb生成的模型是只读的，意味着它们可以用于从数据库中检索数据，但Django不会为这些模型创建迁移来管理数据库模式的更改。如果你需要修改数据库结构，你应该手动创建迁移并指定所需的更改。\n另外，inspectdb不支持所有类型的数据库特性，例如存储过程、触发器、视图、分区等。它主要用于生成基本的表结构模型。对于更复杂的数据库特性，你可能需要手动编写模型代码或寻找第三方工具来帮助你。\nReferences\rpython web框架django面试题 Django的Form和ModeForm的作用？ ","date":"2024-10-15T15:17:09+08:00","permalink":"https://leanmax.github.io/p/django%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%89/","title":"Django面试题（三）"},{"content":"django的request对象是在什么时候创建的？\r当请求一个页面时, Django会建立一个包含请求元数据的HttpRequest对象。\n当Django加载对应的视图时, HttpRequest对象将作为视图函数的第一个参数，另外每个视图会返回一个HttpResponse对象。\nDjango重定向是如何实现的？用的什么状态码？\r使用HttpResponseRedirect 1 2 3 4 5 6 7 from django.http import HttpResponseRedirect def update_time(request): # 表单处理 OR 逻辑处理 return HttpResponseRedirect(\u0026#39;/\u0026#39;) #跳转到主界面 # 如果需要传参数 # return HttpResponseRedirect(\u0026#39;/commons/index/?message=error\u0026#39;) redirect 和 reverse 1 2 3 4 5 6 7 8 9 10 11 from django.core.urlresolvers import reverse from django.shortcuts import redirect def update_time(request): # 进行要处理的逻辑 return redirect(reverse(\u0026#39;test.views.invoice_return_index\u0026#39;, args=[])) # 跳转到index界面 # redirect 类似HttpResponseRedirect的用法， # 也可以使用 字符串的url格式 /..index/？a=add # reverse 可以直接用views函数来指定重定向的处理函数，args是url匹配的值。 状态码：301和302\n相同点：都表示重定向，浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址 不同点： 301比较常用的场景是使用域名跳转。比如，我们访问 http://www.baidu.com 会跳转到 https://www.baidu.com，表示旧地址A的资源已经被永久地移除了 302用来做临时跳转，比如未登陆的用户访问用户中心重定向到登录页面。表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B django中csrf的实现机制\r跨站请求伪造（CSRF，Cross-Site Request Forgery）是一种攻击方式，攻击者诱导用户在已认证的网站上执行非授权操作。攻击者通常通过第三方网站发送恶意请求，让受害者在不知情的情况下使用其已登录的身份发起请求，执行操作。（攻击者可以利用Cookie但不能获取Cookie）\ndjango通过’django.middleware.csrf.CsrfViewMiddleware’这个中间层来完成。\n具体机制：\n用户第一次访问网站时，Django 在响应中生成一个 CSRF Token，并将其存储在 csrftoken Cookie 中。 当用户提交表单时，CSRF Token 被嵌入到表单的隐藏字段中，同时被发送到服务器。 Django 的 CSRF 中间件接收请求后，验证表单中的 Token 和 Cookie 中的 Token 是否匹配。\n如果验证成功，请求通过；如果失败，返回 403 错误。 基于django使用ajax发送post请求时，都可以使用哪种方法携带csrf token？\r将 CSRF Token 添加到请求头：推荐使用 X-CSRFToken，这种方式最常用且最安全。 将 CSRF Token 作为 POST 数据的一部分：适用于需要通过 FormData 提交文件的场景。 Django本身提供了runserver，为什么不能用来部署？(runserver与uWSGI的区别)\rrunserver 是调试 Django 时经常用到的运行方式，它使用 Django 自带的 WSGI Server 运行，主要在测试和开发中使用，并且 runserver 开启的方式也是单进程。 uWSGI 是一个 Web 服务器，它实现了WSGI，uwsgi，HTTP等协议。uwsgi 是一种通信协议，而 uWSGI 是实现 uwsgi 协议和 WSGI 协议的 Web 服务器。uWSGI 具有超快的性能、低内存占用等优点，并且搭配着 Nginx 组成项目的生产环境，能够将用户访问请求与项目应用隔离，实现真正的网站部署。相对来说，这种方式支持的并发量更高，方便管理多进程，发挥多核的优势，提升性能。 cookie和session的区别\r1. 存储位置与数据安全性\rCookie：存储在客户端浏览器中，数据安全性相对较差。因为数据保存在客户端浏览器中，如果用户或第三方工具非法获取Cookie内容，可能导致数据泄露或身份冒用。 Session：数据保存在服务器端，安全性相对较高。因为数据存储在服务器端，可以有效防止数据被非法获取或篡改。 2. 存取方式与数据类型\rCookie：只能保存ASCII字符，因此无法直接存储复杂数据类型，通常用于存储简单的标识信息，如会话ID、用户偏好等。 Session：可以保存任意数据类型，如字符串、数字、对象等。因此，Session可以用于存储更复杂的用户数据，如用户购物车信息、个性化设置等。 3. 有效期与生命周期\rCookie：有效期取决于设置的Expires属性或Max-Age属性，通常在浏览器会话结束时过期（即关闭浏览器时）。另外，用户也可以通过禁用Cookie来影响Cookie的有效期。 Session：有效期通常由服务器配置决定，Session的生命周期通常由服务器清理过期或未活动的会话来管理。 4. 跨域请求与分布式处理\rCookie：由于同源策略的限制，Cookie无法在跨域请求中使用。这意味着如果一个网站需要从其他域获取资源或服务，将无法使用Cookie进行身份验证或会话管理。 Session：在跨域请求中，可以通过将Session存储在中央服务器或使用分布式Session来处理。这样可以在多个域之间共享用户会话信息，实现跨域认证和资源共享。 列举django orm 中所有的方法（QuerySet对象的所有方法）\r1. 查询方法\r这些方法用于检索和获取数据。\nall()：返回所有对象的 QuerySet。\n1 Person.objects.all() get()：根据条件返回单个对象，如果找不到对象或有多个对象匹配条件，则会抛出异常。\n1 Person.objects.get(id=1) filter()：根据条件过滤数据，返回一个新的 QuerySet。\n1 Person.objects.filter(age__gte=18) exclude()：排除符合条件的对象，返回一个新的 QuerySet。\n1 Person.objects.exclude(age__lt=18) first()：返回 QuerySet 中的第一个对象，如果没有对象则返回 None。\n1 Person.objects.filter(age__gte=18).first() last()：返回 QuerySet 中的最后一个对象，如果没有对象则返回 None。\n1 Person.objects.filter(age__gte=18).last() latest()：根据日期字段获取最新的对象（需要指定 get_latest_by）。\n1 Person.objects.latest(\u0026#39;created_at\u0026#39;) earliest()：根据日期字段获取最早的对象。\n1 Person.objects.earliest(\u0026#39;created_at\u0026#39;) exists()：检查是否存在符合条件的对象，返回 True 或 False。\n1 Person.objects.filter(age__gte=18).exists() count()：返回查询集中的对象数量。\n1 Person.objects.filter(age__gte=18).count() 2. 排序与限制\r这些方法用于排序和限制返回的结果。\norder_by()：对查询结果进行排序。\n1 2 Person.objects.order_by(\u0026#39;name\u0026#39;) # 升序 Person.objects.order_by(\u0026#39;-name\u0026#39;) # 降序 distinct()：去除查询结果中的重复记录。\n1 Person.objects.distinct(\u0026#39;name\u0026#39;) reverse()：对查询集的结果进行反转。\n1 Person.objects.all().reverse() values()：返回字典形式的查询结果（只返回指定字段）。\n1 Person.objects.values(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;) values_list()：返回元组形式的查询结果。\n1 Person.objects.values_list(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;) none()：返回一个空的 QuerySet。\n1 Person.objects.none() select_related()：用于一对多和一对一关系的表连接，减少查询次数。\n1 Person.objects.select_related(\u0026#39;profile\u0026#39;) prefetch_related()：用于多对多和反向查询的表连接。\n1 Person.objects.prefetch_related(\u0026#39;books\u0026#39;) only()：只加载指定的字段。\n1 Person.objects.only(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;) defer()：延迟加载指定的字段。\n1 Person.objects.defer(\u0026#39;bio\u0026#39;) select_for_update()：对数据行加锁（用于事务中）。\n1 Person.objects.select_for_update() 3. 聚合与注解\r这些方法用于统计和计算。\naggregate()：执行聚合查询（例如 Sum、Avg 等）。\n1 2 from django.db.models import Avg Person.objects.aggregate(Avg(\u0026#39;age\u0026#39;)) annotate()：在 QuerySet 中添加额外的计算字段。\n1 2 from django.db.models import Count Person.objects.annotate(num_books=Count(\u0026#39;books\u0026#39;)) 4. 更新与删除\r这些方法用于修改或删除数据库中的对象。\nupdate()：对符合条件的对象进行批量更新。\n1 Person.objects.filter(age__lt=18).update(age=18) delete()：删除符合条件的对象。\n1 Person.objects.filter(age__lt=18).delete() bulk_create()：批量创建对象，避免多次数据库写入。\n1 Person.objects.bulk_create([Person(name=\u0026#39;Alice\u0026#39;), Person(name=\u0026#39;Bob\u0026#39;)]) bulk_update()：批量更新对象。\n1 Person.objects.bulk_update([person1, person2], [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;]) 5. 高级查询\r这些方法用于执行更复杂的查询。\nextra()：执行自定义的 SQL 查询（不推荐使用，未来版本将弃用）。\n1 Person.objects.extra(select={\u0026#39;is_adult\u0026#39;: \u0026#39;age \u0026gt;= 18\u0026#39;}) raw()：执行原生 SQL 查询。\n1 Person.objects.raw(\u0026#39;SELECT * FROM myapp_person WHERE age \u0026gt;= %s\u0026#39;, [18]) union()：联合多个 QuerySet。\n1 2 3 qs1 = Person.objects.filter(age__gte=18) qs2 = Person.objects.filter(age__lt=18) qs1.union(qs2) intersection()：取多个 QuerySet 的交集。\n1 2 3 qs1 = Person.objects.filter(age__gte=18) qs2 = Person.objects.filter(age__lt=30) qs1.intersection(qs2) difference()：取多个 QuerySet 的差集。\n1 2 3 qs1 = Person.objects.filter(age__gte=18) qs2 = Person.objects.filter(age__lt=30) qs1.difference(qs2) 6. 缓存与清空\riterator()：逐个获取对象，避免一次性加载所有对象（有助于处理大量数据）。\n1 2 for person in Person.objects.all().iterator(): print(person.name) as_manager()：将一个类方法转换为模型管理器方法。\n1 2 3 4 5 class MyManager(models.Manager): def with_age(self, age): return self.filter(age=age) Person.objects = MyManager.as_manager() 7. 复合查询\ror_ 和 and_：通过 Q 对象进行复杂的查询条件组合。 1 2 from django.db.models import Q Person.objects.filter(Q(name=\u0026#39;Alice\u0026#39;) | Q(age__gte=18)) 总结\rDjango ORM 提供了丰富的 QuerySet 方法，涵盖从简单到复杂的查询、排序、过滤、聚合、更新等功能。合理使用这些方法，可以极大地提升数据查询和操作的效率。\nonly和defer的区别？\r在 Django 的查询集（QuerySet）中，only() 和 defer() 是两种优化查询性能的方法，目的是减少从数据库中获取的数据量，提升查询速度。但它们的工作方式和适用场景有所不同。\n1. only()\ronly() 用于告诉 Django 只从数据库中获取特定字段的数据，其余字段将不会在查询时一同获取。如果访问了未加载的字段，Django 会在访问该字段时进行额外的数据库查询。\n工作原理：\n当使用 only() 时，Django 只会从数据库中查询你指定的字段，其他字段将在实际访问时通过额外的查询获取。 适用于只需要某些字段的场景，避免加载不必要的数据。 示例：\n1 2 3 4 5 6 7 # 只获取 \u0026#39;name\u0026#39; 和 \u0026#39;age\u0026#39; 字段 queryset = Person.objects.only(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;) for person in queryset: print(person.name) # 不会触发额外的查询 print(person.age) # 不会触发额外的查询 print(person.address) # 访问未指定的字段，触发额外的数据库查询 特点：\n加载指定字段：只加载 only() 中指定的字段，其他字段延迟加载。 可能导致额外查询：当访问未加载的字段时，Django 会进行额外的查询获取该字段的值（N+1 查询问题）。 适用场景：\n适合只需要部分字段的场景，尤其是查询结果中有很多字段但并不都需要立即使用时，可以通过 only() 提前减少数据库负担。 2. defer()\rdefer() 与 only() 相反，它告诉 Django 延迟加载某些字段。即在查询时获取所有字段，除了你指定的字段之外，其他字段将在实际访问时进行额外的查询。\n工作原理：\n使用 defer() 时，Django 会查询除指定字段以外的所有字段。访问被延迟加载的字段时，会触发额外的数据库查询。 示例：\n1 2 3 4 5 6 7 # 延迟加载 \u0026#39;bio\u0026#39; 字段，其他字段会立即加载 queryset = Person.objects.defer(\u0026#39;bio\u0026#39;) for person in queryset: print(person.name) # 不会触发额外的查询 print(person.age) # 不会触发额外的查询 print(person.bio) # 访问延迟加载的字段，触发额外的数据库查询 特点：\n延迟指定字段的加载：在查询时加载所有字段，除了 defer() 中指定的字段，访问这些字段时才会进行数据库查询。 减少初次查询的数据量：通过延迟不需要立即使用的字段，减少初次查询中的数据量。 适用场景：\n当你需要大部分字段，但有一些字段不经常使用时，可以使用 defer() 延迟这些字段的加载，以减少初次查询的开销。 only() 和 defer() 的对比\r特性 only() defer() 目的 只加载指定字段 延迟加载指定字段 初次查询的字段 只查询指定的字段，其余字段延迟加载 查询所有字段，除了被延迟的字段 额外查询 访问未加载的字段时，触发额外的数据库查询 访问延迟加载的字段时，触发额外的数据库查询 适用场景 只关心某些字段，其他字段可以延迟加载 大部分字段需要立即使用，但部分字段可以延迟加载 总结\ronly()：告诉 Django 只查询指定字段，其他字段延迟加载。适合在只需要少数几个字段的场景中使用。 defer()：告诉 Django 查询所有字段，除了那些被延迟加载的字段。适合需要大部分字段但不需要立即使用某些字段的情况。 select_related和prefetch_related的区别？\rselect_related 和 prefetch_related 都用于优化查询并减少数据库查询次数，但它们的作用机制和适用场景有所不同。下面详细介绍它们的区别：\n1. 适用的关系类型\rselect_related：用于一对一和外键（一对多）关系。\n它会使用 SQL 的 JOIN 操作，将相关对象的数据一次性从数据库中取出，减少查询次数。 适用于对象之间有直接的外键或一对一关系的情况。 prefetch_related：用于多对多和反向外键查询（即从“多”查“1”）。\n它会执行额外的查询来获取相关对象的数据，并在 Python 层面将这些查询结果与主查询的结果进行合并。 适用于多对多关系或外键的反向关系。 2. 查询次数\rselect_related：使用 SQL 的 JOIN 操作，只需要一次数据库查询就能获取主对象和相关对象的数据。\n比如，如果你有一个 Person 表和一个与之相关的 Profile 表（外键关系），使用 select_related 会在一次查询中把 Person 和对应的 Profile 数据一起获取。 prefetch_related：会执行多个数据库查询，先查询主对象，再执行额外的查询来获取相关对象的数据。然后在内存中将结果进行匹配。\n比如，当你有 Person 表和 Book 表（多对多关系），使用 prefetch_related 会先查询 Person，然后进行第二次查询来获取 Book 的数据。 3. 性能对比\rselect_related：由于使用了 SQL JOIN，在处理一对一或外键关系时性能通常更好，因为只需要一次查询。但是如果涉及到太多的表 JOIN 操作，查询变得复杂时，性能可能会下降。\nprefetch_related：在多对多关系或反向外键关系下，使用 select_related 不能达到优化的效果，因为 JOIN 复杂的多对多表会产生大量重复数据。此时，prefetch_related 更合适，因为它在 Python 中处理数据，避免了复杂的 JOIN，能更好地减少冗余数据。\n4. 示例\r使用 select_related（外键关系）\r1 2 3 4 # Person 表有一个外键指向 Profile 表 persons = Person.objects.select_related(\u0026#39;profile\u0026#39;).all() # 这只需要一次查询，获取 Person 和 Profile 的数据。 使用 prefetch_related（多对多关系）\r1 2 3 4 # Person 表和 Book 表是多对多关系 persons = Person.objects.prefetch_related(\u0026#39;books\u0026#39;).all() # 这会执行两次查询：一次查询 Person，一次查询 Person 对应的 Book 数据。 5. 总结\r特性 select_related prefetch_related 适用关系 一对一、外键（多对一） 多对多、反向外键 数据库查询次数 只执行一次查询 执行多次查询 工作原理 使用 SQL JOIN 在一次查询中获取所有相关数据 进行多个查询，并在 Python 层面将结果合并 性能表现 适用于简单的关系；太多 JOIN 操作时性能可能下降 适用于复杂关系（特别是多对多），避免大量重复数据 示例场景 Person 和 Profile（外键/一对一） Person 和 Book（多对多） 根据关系类型和性能需求，选择合适的方法可以有效优化 Django ORM 的数据库查询效率。\nfilter和exclude的区别？\r在 Django ORM 中，filter() 和 exclude() 都用于查询数据，但它们的作用相反：\n1. filter()：\r用于筛选出符合条件的记录。 返回满足条件的对象集（QuerySet）。 示例：\r假设你有一个 User 模型，想要筛选出所有 age=30 的用户：\n1 users = User.objects.filter(age=30) 结果：\n返回 age 为 30 的所有用户。 2. exclude()：\r用于排除不符合条件的记录。 返回不满足条件的对象集（QuerySet）。 示例：\r想要查询所有 age != 30 的用户：\n1 users = User.objects.exclude(age=30) 结果：\n返回不是 30 岁的用户。 区别总结：\rfilter()：选出符合条件的记录。 exclude()：排除符合条件的记录，返回其余不满足条件的记录。 对比示例：\r1 2 3 4 5 # 查找年龄为 30 岁的用户 users_filtered = User.objects.filter(age=30) # 查找年龄不是 30 岁的用户 users_excluded = User.objects.exclude(age=30) 返回结果：\rfilter() 返回的 users_filtered 包含所有年龄为 30 岁的用户。 exclude() 返回的 users_excluded 包含所有不是 30 岁的用户。 两个方法可以结合使用，比如你可以先使用 filter() 来细化查询范围，再使用 exclude() 来排除某些结果。\nF和Q的作用?\r在 Django ORM 中，F 和 Q 是两个强大的查询表达式工具，用于构建更加灵活和复杂的查询条件。\n1. F 对象：\rF 对象允许在查询中引用模型字段本身，特别适合需要比较字段之间的值或者对字段进行原子更新的场景。\n主要作用：\r字段之间的比较：可以在查询中比较一个字段与另一个字段的值。 原子更新：在更新操作中可以直接基于现有字段值进行计算（如递增、递减）。 示例：\ra) 字段间比较：\r假设你有一个 Product 模型，包含 price 和 discount_price 两个字段，想要查询 price 大于 discount_price 的产品。\n1 2 3 from django.db.models import F products = Product.objects.filter(price__gt=F(\u0026#39;discount_price\u0026#39;)) 结果：\n返回 price 大于 discount_price 的所有产品。 b) 原子更新：\r假设你想要将某个字段的值基于其现有值增加一定数量，比如增加库存数量。\n1 Product.objects.filter(id=1).update(stock=F(\u0026#39;stock\u0026#39;) + 10) 结果：\n将 id=1 的产品库存增加 10。Django 会直接在数据库层面进行更新，避免了取出、修改再保存的额外步骤。 2. Q 对象：\rQ 对象用于构建更加复杂的查询条件，尤其是需要在查询中使用逻辑运算符（如 AND、OR、NOT）时非常有用。\n主要作用：\r组合复杂的条件：可以通过 \u0026amp;（AND）、|（OR）、~（NOT）操作符组合查询条件。 处理条件之间的逻辑关系：特别是在你需要做 OR 查询或排除某些条件时非常有用。 示例：\ra) OR 查询：\r假设你想查询 age=30 或 name=\u0026quot;John\u0026quot; 的用户。\n1 2 3 from django.db.models import Q users = User.objects.filter(Q(age=30) | Q(name=\u0026#39;John\u0026#39;)) 结果：\n返回年龄为 30 岁的用户或名字为 \u0026ldquo;John\u0026rdquo; 的用户。 b) AND 查询：\r默认情况下，filter() 使用 AND 操作符，但你可以显式使用 \u0026amp; 来构建复杂的 AND 查询。\n1 users = User.objects.filter(Q(age=30) \u0026amp; Q(name=\u0026#39;John\u0026#39;)) 结果：\n返回年龄为 30 且名字为 \u0026ldquo;John\u0026rdquo; 的用户。 c) NOT 查询：\r可以使用 ~ 运算符来表示逻辑 NOT。\n1 users = User.objects.filter(~Q(age=30)) 结果：\n返回年龄不是 30 岁的用户。 3. F 和 Q 结合使用：\rF 和 Q 可以一起使用来构建更复杂的查询。例如，查找所有 price \u0026gt; discount_price 或 stock \u0026lt; 10 的产品：\n1 products = Product.objects.filter(Q(price__gt=F(\u0026#39;discount_price\u0026#39;)) | Q(stock__lt=10)) 结果：\n返回 price 大于 discount_price 或者库存小于 10 的产品。 总结：\rF 对象：用于在查询或更新时引用模型字段本身，支持字段之间的比较和原子更新操作。 Q 对象：用于构建复杂的查询条件，支持逻辑运算（AND、OR、NOT）来组合不同的条件。 values和values_list的区别？\r在 Django ORM 中，values() 和 values_list() 都用于从数据库中提取特定字段的数据，但它们的返回结果形式不同：\n1. values()：\r返回一个字典（dictionary）的 QuerySet，其中每个字典的键是字段名，值是字段的值。 通常用于获取一组对象的特定字段及其对应值，结果类似于字典的列表。 示例：\r假设有一个 User 模型，包含字段 id、username 和 email。\n1 users = User.objects.values(\u0026#39;id\u0026#39;, \u0026#39;username\u0026#39;) 结果：\n1 2 3 4 5 [ {\u0026#39;id\u0026#39;: 1, \u0026#39;username\u0026#39;: \u0026#39;JohnDoe\u0026#39;}, {\u0026#39;id\u0026#39;: 2, \u0026#39;username\u0026#39;: \u0026#39;JaneDoe\u0026#39;}, # ... ] 结果中每个条目是一个字典，包含 id 和 username 字段。 2. values_list()：\r返回一个元组（tuple）的 QuerySet，其中每个元组包含所查询字段的值。 如果只查询一个字段，则可以设置 flat=True 来获取一个简单的列表。 通常用于获取字段值的列表或元组形式，效率上略优于 values()，因为它避免了字典构造的开销。 示例：\ra) 获取多个字段：\r1 users = User.objects.values_list(\u0026#39;id\u0026#39;, \u0026#39;username\u0026#39;) 结果：\n1 2 3 4 5 [ (1, \u0026#39;JohnDoe\u0026#39;), (2, \u0026#39;JaneDoe\u0026#39;), # ... ] 结果是一个元组的列表，每个元组对应 id 和 username 的值。 b) 获取单个字段：\r使用 flat=True 时，只返回一个字段的平铺列表。\n1 usernames = User.objects.values_list(\u0026#39;username\u0026#39;, flat=True) 结果：\n1 [\u0026#39;JohnDoe\u0026#39;, \u0026#39;JaneDoe\u0026#39;, ...] 结果是一个简单的列表，包含所有用户的 username 字段。 区别总结：\r方法 返回类型 示例结果 适用场景 values() 字典的 QuerySet [{'id': 1, 'username': 'JohnDoe'}, ...] 需要键值对时 values_list() 元组的 QuerySet [(1, 'JohnDoe'), (2, 'JaneDoe')] 需要字段值的列表或元组时 values_list(flat=True) 列表（单个字段） ['JohnDoe', 'JaneDoe'] 只需要某个字段的简单列表时 总结：\rvalues()：返回包含字段名和对应值的字典列表，适合需要字段名与值一一对应的场景。 values_list()：返回字段值的元组列表，如果只查询一个字段且使用 flat=True，返回平铺列表，适合只关心字段值本身的场景。 References\rpython web框架django面试题 Django本身提供了runserver，为什么不能用来部署？ ","date":"2024-10-14T20:21:44+08:00","permalink":"https://leanmax.github.io/p/django%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/","title":"Django面试题（二）"},{"content":"对Django的认识\rDjango是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用其ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。 Django内置的ORM跟框架内的其他模块耦合程度高。应用程序必须使用Django内置的ORM，否则就不能享受到框架内提供的种种基于其ORM的便利； Django适用的是中小型的网站，或者是作为大型网站快速实现产品雏形的工具。 Django模板的设计哲学是彻底的将代码、样式分离；Django从根本上杜绝在模板中进行编码、处理数据的可能。 Django，Flask和Tornado的对比\r框架定位\nDjango：全栈框架，功能全面，内置ORM、认证、后台管理等，适合中大型项目。 Flask：轻量微框架，灵活性高，适合小型应用和需要定制化的项目。 Tornado：异步Web框架，擅长高并发和实时通讯，适合实时系统和高并发场景。 开发效率\nDjango：内置功能多，开发效率高，但灵活性相对较低。 Flask：简洁灵活，开发者有更多技术选择空间，但需自行集成扩展。 Tornado：异步模式高效并发，但开发和调试复杂。 性能与适用场景\nDjango：适合企业级应用，性能一般，但可通过缓存等手段优化。 Flask：轻量，适合API和小型项目，需外部工具提升并发性能。 Tornado：异步架构，适合高并发、WebSocket等实时应用，性能最优。 总结\nDjango：适合功能复杂、需要快速开发的项目。 Flask：适合灵活定制的小型应用或微服务。 Tornado：适合高并发、实时通讯的系统。 Web服务器和Web框架的区别\rWeb服务器即用来接受客户端请求，建立连接，转发响应的程序。至于转发的内容是什么，交由Web框架来处理，即处理这些业务逻辑。如查询数据库、生成实时信息等。 Nginx是一个Web服务器，Django或flask就是Web框架。\n什么是WSGI,uWSGI,uwsgi,aWSGI？\rWSGI，Web服务器网关接口，是一种Web服务器网关接口，它是一个Web服务器（如Nginx，uWSGI等服务器）与Web应用（如Flask框架写的程序）通信的一种规范。当前运行在WSGI协议之上的Web框架有Bottle，Flask，Django uWSGI，是实现了WSGI协议的一个Web服务器。即用来接受客户端请求，转发响应的程序。实际上，一个uWSGI的Web服务器，再加上Django这样的Web框架，就已经可以实现网站的功能了。 uwsgi，uwsgi 是一个与 uWSGI 服务器相关的协议。uwsgi 协议是一种二进制协议，它定义了 uWSGI 服务器与应用程序之间的通信协议。使用 uwsgi 协议，uWSGI 服务器可以与 Python 应用程序通信 aWSGI，异步网关协议接口，一个介于网络协议服务和Python应用之间的标准接口，能够处理多种通用的协议类型，包括HTTP，HTTP2和WebSocket。 WSGI和ASGI的区别\rWSGI是基于HTTP协议模式的，不支持WebSocket，而ASGI的诞生则是为了解决Python常用的WSGI不支持当前Web开发中的一些新的协议标准。同时，ASGI对于WSGI原有的模式的支持和WebSocket的扩展，即ASGI是WSGI的扩展。\nDjango的生命周期\rwsgi,请求封装后交给web框架 （Flask、Django） 中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf、request.session 路由匹配,根据浏览器发送的不同url去匹配不同的视图函数 视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm、templates =\u0026gt; 渲染 中间件，对响应的数据进行处理。 wsgi,将响应的内容发送给浏览器。 什么是FBV和CBV？\rFBV（function base views）： 基于函数的视图，就是在视图里使用函数处理请求。 CBV（class base views）： 基于类的视图，就是在视图里使用类处理请求。\nFBV\r就是使用了函数来处理用户的请求，查看以下实例：\n路由配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # urls.py urlpatterns = [ path(\u0026#34;login/\u0026#34;, views.login), ] # views.py from django.shortcuts import render,HttpResponse def login(request): if request.method == \u0026#34;GET\u0026#34;: return HttpResponse(\u0026#34;GET 方法\u0026#34;) if request.method == \u0026#34;POST\u0026#34;: user = request.POST.get(\u0026#34;user\u0026#34;) pwd = request.POST.get(\u0026#34;pwd\u0026#34;) if user == \u0026#34;runoob\u0026#34; and pwd == \u0026#34;123456\u0026#34;: return HttpResponse(\u0026#34;POST 方法\u0026#34;) else: return HttpResponse(\u0026#34;POST 方法1\u0026#34;) CBV\r基于类的视图，就是使用了类来处理用户的请求，不同的请求我们可以在类中使用不同方法来处理，这样大大的提高了代码的可读性。\n定义的类要继承父类 View，所以需要先引入库：\nfrom django.views import View 执行对应请求的方法前会优先执行 dispatch 方法(在get/post/put\u0026hellip;方法前执行)，dispatch() 方法会根据请求的不同调用相应的方法来处理。\n其实，在我们前面学到的知识都知道 Django 的 url 是将一个请求分配给可调用的函数的，而不是一个类，那是如何实现基于类的视图的呢？ 主要还是通过父类 View 提供的一个静态方法 as_view() ，as_view 方法是基于类的外部接口， 他返回一个视图函数，调用后请求会传递给 dispatch 方法，dispatch 方法再根据不同请求来处理不同的方法。\n路由配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # urls.py urlpatterns = [ path(\u0026#34;login/\u0026#34;, views.Login.as_view()), ] # views.py from django.shortcuts import render,HttpResponse from django.views import View class Login(View): def get(self,request): return HttpResponse(\u0026#34;GET 方法\u0026#34;) def post(self,request): user = request.POST.get(\u0026#34;user\u0026#34;) pwd = request.POST.get(\u0026#34;pwd\u0026#34;) if user == \u0026#34;runoob\u0026#34; and pwd == \u0026#34;123456\u0026#34;: return HttpResponse(\u0026#34;POST 方法\u0026#34;) else: return HttpResponse(\u0026#34;POST 方法 1\u0026#34;) 如何给CBV的程序添加装饰器？\r对单个方法使用装饰器：使用@method_decorator装饰get、post等方法。 1 2 3 4 5 6 7 8 9 from django.utils.decorators import method_decorator from django.contrib.auth.decorators import login_required from django.views.generic import View from django.http import HttpResponse class MyView(View): @method_decorator(login_required) def get(self, request, *args, **kwargs): return HttpResponse(\u0026#34;This is a protected view\u0026#34;) 对整个类视图使用装饰器：使用@method_decorator装饰dispatch方法，影响所有请求方法。 1 2 3 4 5 6 7 8 9 10 11 12 from django.utils.decorators import method_decorator from django.contrib.auth.decorators import login_required from django.views.generic import View from django.http import HttpResponse @method_decorator(login_required, name=\u0026#39;dispatch\u0026#39;) class MyView(View): def get(self, request, *args, **kwargs): return HttpResponse(\u0026#34;This is a protected view\u0026#34;) def post(self, request, *args, **kwargs): return HttpResponse(\u0026#34;This is a protected view for POST request\u0026#34;) 简述MVC和MTV\rMVC（Model View Controller 模型-视图-控制器）\r​ Web服务器开发领域里著名的MVC模式，所谓MVC就是把Web应用分为模型(M)，控制器(C)和视图(V)三层，他们之间以一种插件式的、松耦合的方式连接在一起，模型负责业务对象与数据库的映射(ORM)，视图负责与用户的交互(页面)，控制器接受用户的输入调用模型和视图完成用户的请求，其示意图如下所示：\nMVC模式示意图 M-\u0026gt;Model:模型，主要负责在数据库中对数据的存取操作 V-\u0026gt;View:视图，负责显示数据，通常是前端界面，如HTML页面、UI元素等。它接收用户输入并将其传递给Controller。 C-\u0026gt;Controller:控制器，充当Model和View之间的桥梁。它处理来自View的用户请求，调用Model中的业务逻辑，返回结果给View进行显示。 MTV（Model Templates View 模型-模板-视图）\rDjango的MTV模式本质上与MVC是一样的，也是为了各组件之间保持松耦合关系，只是在定义上有些不同，Django的MTV分别是：\nM-\u0026gt;模型(Model)：和MVC中的Model类似，处理与数据相关的内容，定义数据库的结构和操作方法 T-\u0026gt;模板(Template)：相当于MVC中的View，负责将数据呈现给用户。模板通过Django的模板语言生成动态HTML页面 V-\u0026gt;视图(View)：与MVC的Controller功能类似，负责处理用户请求和业务逻辑，调用Model获取数据，并将结果传递给Template进行渲染 还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template，MTV的响应模式如下所示：\nMTV模式示意图 ​ 一般是用户通过浏览器向我们的服务器发起一个请求(request)，这个请求回去访问视图函数，（如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户），视图函数调用模型，模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。\nMVC和MTV的区别\rMVC中的V的目的是呈现那个数据，而MTV的V的目的是数据如何呈现\n也就是把MVC中的View分成了视图（展现哪些数据）和模板（如何展现）2个部分，而Contorller这个要素由框架自己来实现了，我们需要做的就是把（带正则表达式的）URL对应到视图就可以了，通过这样的URL配置，系统将一个请求发送到一个合适的视图。\nDjango框架中配置url路由时name的作用\r主要是通过name的值，来查找url地址，可以理解为反射作用（别名）。在html模板中使用name来反射url优势就是后期url规则发生改变之后，只需调整urls.py即可，所有的模板文件都不需要修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # urls.py urlpatterns = [ path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;sum/\u0026#39;, views.add, name=\u0026#34;add\u0026#34;), path(\u0026#39;get_url/\u0026#39;, views.get_url, name=\u0026#34;test\u0026#34;), path(\u0026#39;index/\u0026#39;, views.index), ] # views.py def add(request): return HttpResponse(\u0026#39;你访问了第一个url路由\u0026#39;) def get_url(request): # reverse()这个函数就是根据url路由的name参数，来反向获取url地址的方法 # 所以，url路由的name参数不仅仅可以在模板中使用{% url \u0026#39;add\u0026#39; %}，也可以在view.py中使用 result = reverse(\u0026#39;add1\u0026#39;, args=(123, 456)) return HttpResponse(result) 1 2 3 4 5 6 7 {# 上述使用name字段的url路由设置方法在html文件中的应用方式如下： #} {# url是固定写法，表示当前要加载的是url地址。\u0026#39;add\u0026#39;表示url路由对应的name参数值。 #} {# 要加载name=\u0026#34;add\u0026#34;的这个url地址。 #} \u0026lt;a href=\u0026#34;{% url \u0026#39;add\u0026#39; %}\u0026#34;\u0026gt;第一个url路由\u0026lt;/a\u0026gt; {# 通过name的值\u0026#34;add1\u0026#34;，反向获取带有参数的url地址 #} \u0026lt;a href=\u0026#34;{% url \u0026#39;add1\u0026#39; 10 25 %}\u0026#34;\u0026gt;计算\u0026lt;/a\u0026gt; 列举django的内置组件？\rDjango 是一个功能强大的全栈框架，提供了大量内置组件，帮助开发者快速构建和维护Web应用。这些内置组件涵盖了从数据管理、用户身份认证到安全性、性能优化等方面的需求。\n以下是 Django 的一些重要内置组件：\n1. 模型（Model）\rORM（Object-Relational Mapping）：Django 提供了内置的 ORM 系统，帮助开发者通过 Python 类定义数据库表结构，而不需要直接写 SQL。常用组件包括： models.Model：基础模型类。 字段类型：CharField，IntegerField，DateField 等。 关系字段：ForeignKey，ManyToManyField，OneToOneField。 2. 视图（View）\r基于函数的视图（FBV）：使用普通的 Python 函数处理 HTTP 请求，例如： 1 2 def my_view(request): return HttpResponse(\u0026#34;Hello, world!\u0026#34;) 基于类的视图（CBV）：提供了一系列通用视图类，简化了开发常见的视图逻辑： ListView：用于展示对象列表。 DetailView：展示单个对象的详细信息。 CreateView，UpdateView，DeleteView：处理对象的创建、更新、删除操作。 3. 模板引擎（Template Engine）\rDjango 内置了一个模板系统，允许开发者使用模板语言生成动态 HTML 页面。常用的模板标签和过滤器包括： 变量输出：{{ variable }} 控制结构：{% for item in list %} ... {% endfor %}，{% if condition %} ... {% endif %} 过滤器：{{ name|upper }}，{{ date|date:\u0026quot;Y-m-d\u0026quot; }} 4. URL 路由（URL Routing）\rDjango 提供了灵活的 URL 路由系统，允许开发者通过 urls.py 文件定义 URL 模式与视图函数的映射： 1 2 3 4 5 6 from django.urls import path from . import views urlpatterns = [ path(\u0026#39;home/\u0026#39;, views.home_view, name=\u0026#39;home\u0026#39;), ] 支持正则表达式匹配和命名路由。 5. 表单处理（Forms）\rDjango 提供了强大的表单处理组件，支持表单生成、验证、以及与模型的绑定。 forms.Form：手动定义表单结构。 forms.ModelForm：自动生成与模型关联的表单。 支持表单字段验证和错误处理。 6. 认证和授权系统（Authentication and Authorization）\rDjango 内置了完整的用户身份认证和权限管理系统： django.contrib.auth：提供用户模型、身份验证、权限、用户组等。 常用组件： User 模型：用于用户注册、登录。 LoginRequiredMixin：用于限制用户访问某些视图。 PermissionRequiredMixin：基于权限控制视图的访问。 7. 管理界面（Admin）\rDjango 内置了强大的后台管理界面，无需额外开发即可管理模型数据。 django.contrib.admin：自动生成管理后台，通过 admin.site.register 将模型注册到后台。 支持自定义表单、过滤器、搜索等功能。 8. 中间件（Middleware）\rDjango 提供了中间件机制，可以在请求和响应的处理过程中添加额外的逻辑。 常见的内置中间件包括： SecurityMiddleware：处理安全相关的功能（如强制 HTTPS）。 AuthenticationMiddleware：处理用户的身份认证。 SessionMiddleware：启用会话支持。 CommonMiddleware：处理URL重定向、内容长度等。 9. 消息框架（Messages Framework）\rDjango 的消息框架允许在不同请求之间传递一次性消息（如成功提示、错误消息）。 django.contrib.messages：常用于提示用户操作结果，如表单提交成功。 使用 messages.add_message 或 messages.success，messages.error 等方法显示消息。 10. 文件上传处理（File Handling）\rDjango 提供了简便的文件上传和处理机制。 FileField 和 ImageField：用于在模型中定义文件上传字段。 request.FILES：处理上传的文件。 11. 信号（Signals）\rDjango 提供了信号机制，允许在某些事件发生时触发特定的回调函数。 常用信号：pre_save，post_save，pre_delete，post_delete。 开发者可以使用信号来处理特定事件，如模型保存后执行额外逻辑。 说一下Django，MIDDLEWARES中间件的作用和应用场景？\r中间件是介于request与response处理之间的一道处理过程,用于在全局范围内改变Django的输入和输出。\n简单的来说中间件是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作\n例如：\nDjango项目中默认启用了csrf保护,每次请求时通过CSRF中间件检查请求中是否有正确token值 当用户在页面上发送请求时，通过自定义的认证中间件，判断用户是否已经登陆，未登陆就去登陆。 当有用户请求过来时，判断用户是否在白名单或者在黑名单里 列举django中间件的5个方法？\r方法 作用 process_request(self, request) 主要方法。请求刚进来时，执行视图函数之前调用。(无return) process_view(self, request, callback, callback_args, callback_kwargs) URL路由匹配成功后，执行视图函数之前调用，拿到视图函数对象，及其所有参数。(无return) process_exception(self, request, exception) 执行视图函数中遇到异常时调用。(无return) process_template_response(self, request, response) 很少用。执行了render()渲染方法后调用。(有return) process_response(self, request, response) 主要方法。执行视图函数结束之后有响应时调用。(有return) References\rpython web框架django面试题 https://www.runoob.com/django/django-views-fbv-cbv.html Django简介与MTV模式 Django框架中配置url路由时name的作用 列举django中间件的5个方法？以及django中间件的应用场景？ ","date":"2024-10-13T21:57:51+08:00","permalink":"https://leanmax.github.io/p/django%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/","title":"Django面试题（一）"},{"content":"宇宙级免责声明\r本人无意泄露各高校试题，严格遵守任何保密协议，如有不妥随时私信，本人将立刻删除相关内容。本文章的所有内容都仅代表本人观点，如有不同观点，欢迎友善交流~\n写在前面\r关于信息差：保研是一场重大的信息差备赛，有的同学可能从大一刚入学就开始准备了，有的到大三下才真正开始了解保研（比如我），大三下开始会很吃亏！！规划的太晚，不清楚自己想走学术还是就业，没有及时套磁（很多三四月份甚至更早就开始联系导师了），总之早点确认自己的方向总不会错啦。这里也强烈推荐计算机保研er的破茧利器——全国最大非商业用爱交流计算机保研交流群（虽然潜水几个月lru了好几次hh，但是真心推荐！！） 关于套磁：其次就是要勇敢地去套磁，其实整个保研周期我的套磁都挺失败的，周围一套一个准，我套磁之前总会想着老师会不会嫌自己太菜、经历不匹配啥的，总之有点焦虑过头而错过了很多好时机（infj哭死），其实大家都差不多，甚至水平不如自己，勇敢冲就是了！ 关于海王：夏令营我的整体策略就四个字：多多益善。相较于担心老师那边不好回绝，在夏令营阶段更需要担心的是能否拿到一个保底的offer（大佬除外），也有部分提前套磁好的弱com的同学，自然也不必参加过多的夏令营，毕竟确实耗钱耗时间耗精力。当然，在有铁offer并且满意的前提下，也应该及时释放掉多余的offer，减少对老师招生带来的影响，也避免学弟学妹被拉入黑名单。 个人情况\r院校：次九 专业排名：SE，前2% 竞赛：非算法类竞赛若干，有果酱，没有牌子 科研：一段本校隐私计算方面的科研，B刊在投 工程：一段医学交叉的横向，从0到1搭起来的系统，比较solid，基本都能答上 外语：CET-6（不到500，和CET-4成绩相差巨大，是个雷点） 个人意向：70%就业向，title == 导师 \u0026gt; 方向 \u0026raquo; 地域，因为就业意向偏重，主要还是看导儿放不放实习 最终去向：清软专硕 前期准备\r前期主要是在各种文书的准备和无效套磁中（悲），套磁就不误人子弟了。文书方面主要包括了简历、个人陈述、PPT、套磁信、推荐信、中英文自我介绍、成绩单、排名证明……\n简历我这里用的是超级简历，当然也可以直接用word做，绿裙里有相关的模板可以拿来用，主要是要不断迭代完善，建议是保留好每一次的修改，我的简历从五月末到929已经出了15版，针对于每次面试老师偏好的点进行针对性修改完善，也伴随着可能出现科研成果上的更新而更新，并且一定要对简历上的每一个字负责，问穿就尴尬了。\n然后就是个人陈述，有一部分学校是要求提交个人陈述的，这个建议提前写好，一般学校也不会以此为参考，主要准备好500、1000和2000字三个版本，直接针对每个学校稍微改改交上去就好。\nPPT的话可以提前准备好一份，模块化处理，比如基本情况介绍可以1~2页，简单列一下rk、奖学金、竞赛之类的，然后项目经历每个3~4页，科研经历每个5~6页，针对每个学校的要求适当增删，套磁面试的时候一般不太卡时间，适当详细一点是没问题的。可以用本校的模板，也可以用面试学校的模板，但一定要做到整洁干净，不能太花哨，动画也建议少，以免播不出来出岔子。\n中英文自我介绍建议都准备1分钟、3分钟和5分钟版本的，一定要做到肌肉记忆般熟练，同简历一样，也要对自己说的每一句话有百分之一百的把握。\n推荐信的话并不是每个学校都需要，但是提前准备好总没错，一般是要两名职称副教授以上的（计算所需要两名教授职称的），建议直接找好两位教授，能要到电子签名最好（虽然一般不给）。\n夏令营情况\r整体来说，我的夏令营投递是偏保守的（真的很担心没保底），基本投了所有学校（但主要集中在华五），并且大部分都是学硕，导致整个七月份都是在奔波度过，下面就是我的夏令营基本情况。\n院校 入营情况 是否优营 备注 南大cs学硕 否 否 线上被刷 南大ai学硕 否 否 感觉和cs被刷有一定关系 南大se学硕 否 否 感觉和cs被刷有一定关系 人大gl学硕 否 否 本来也没抱啥希望 人大信院学硕 否 否 迷之bar。。。 复旦cs学硕 否 否 普信旦是这样的，后面紧急扩散了 北大软微 是 否 科研向了，拒绝了就包没优营的 武大cs学硕 是 是 上交电院se直硕 是 是 其实只有联培。。。 中科院计算所学硕 否（计算所霸面） 否 被三个组霸面，因为方向问题都拒了 中科院软件所学硕 是（和sjtu冲突） 否 中大cs学硕 是（和sjtu冲突） 否 科大网安学硕 是 是 人均优营，重要是双选，但是还是穿了 浙大CAD\u0026amp;CG 是 是 项目制考核，夏令营只有直博 哈工深CS学硕 否 否 今年bar很高 南大CS学硕\r南大今年开的很早，五月初就出结果了，但是南大需要先双机位通过线上测试才能够参加线下营，南大也是出了名的强com，试题的范围涉及很广，我甚至还提前一天去开了间酒店通宵复习408（血亏），结果今年考了不少编译原理和离散，这简直对我来说是天崩开局，因此也就无疾而终了。总之还是要感谢一下南大肯给我入营的机会，否则我的夏令营投递策略还会更加保守。\n（ps: 听说南大给的酒店巨好，可惜无福消受了555）\n人大信院学硕\r这我是万万没想到的，整个保研周期最让我感到震惊的bar，之前一直以为人大信院是个保底的存在，也联系好了一个评价巨好的老师，结果居然连营都没入，甚至老师都怀疑我是不是报错了，后面也替我亲自去问了教务（真的好感动），感觉是我整个保研过程中最看好我的老师了555。\n亲自问学院（好好的老师啊啊啊啊） 北大软微\r为了错峰出行，也为了进入梦校，软微我报了方向2，通过初筛后还有一轮论文筛，会给个list，其中挑一篇感兴趣的写一篇阅读报告，方向2感觉真的不太卷，而且和我本科研究方向比较契合，只要多看几遍论文，仔细写好阅读报告基本都能入。\n作为第一个线下营，上来就北大对我这个菜鸟十分不友好，提前一天就到了大兴，不得不说软微这个位置确实有点偏僻，校区也很小。\n软微校门 软微夏令营今年分为了三天，第一天是宣讲和各个方向的座谈会，后面两天笔试+面试，不过方向2人不算多，6号基本都结束了。\n笔试的难度不高，30min手撕三道，基本都能写出来。面试的话只能提交3页的pdf还是有点局促的，也算是最罕见的要求了，面试的老师都挺和蔼的，不会的话也不会过多为难，整体气氛十分欢快。\n后续：面试后陆续有三位老师联系了我，但知道了不放实习+本人想要尝试更多学校，和父母、学长仔细斟酌后还是放弃了offer（软微要承诺一定来才会发优营）。\nps：软微夏令营在科研向的道路上渐行渐远了，虽然也有羊导，但是今年方向2基本都是搞科研的了（毕竟报销学费）\n算是拒绝过北大的人了，老师也超nice的！！ 整体来说，软微的夏令营体验还是相当棒的，无论是入营礼包（T恤+饭票），还是没有架子的老师们，都给人一种额外的归属感。面试后我还去绕天安门附近夜骑了一圈，尝了卤煮（好吃嘿嘿）、豆汁儿（难以接受），这次首都之行还是很满意的！ 武大CS学硕\r武大夏令营开的算是不错的了，甚至提供两晚汉庭+包饭，离学校超近，校园也是超好看的（可惜樱花季已经过了）。\n武大校门 整体来说，夏令营时间安排挺紧凑的，第一天上午报到+宣讲，下午机试，因为早上要很早报到+中午没睡，下午脑子一团浆糊，机试五道题，涉及的算法还挺广的，最后就做出了一两道，其他纯在骗分，机试直接原地大爆炸。 第二天就只有面试了，面试是坐在大方桌的主持人座，老师在两侧，摄像机从对面录像，因为有了软微的经验，面试的整个过程还是相当顺利的，都是简历面，也基本都能答上来。\n傍晚的武大 后续：过了没几天发了优营名单，背景评估、机试分、面试分三者综合打出一个综合分，感觉算是十分公开透明的了（点赞）。我虽然在优营名单中，但志不在此，就没有去联系导师了。\n武大是我高考的梦校，尽管不是最终去向，但还是很感激武大能够给我这次机会~\n上交软院（智慧应用方向）\r上交CS直硕的bar一直很高，为了求稳我报了软院（但是软院感觉除了IPADS性价比都不高，但IPADS也是出了名的难）。\n上交软院在线下参营前会公布各个方向（线上宣讲）及其具体的入营任务，大多数是读论文，选定了论文就是选定了方向。后面还会有一次方向调整的机会，通过邮件的方式告诉你各个方向的竞争指数，为了错峰选了智慧应用，但是后来出了竞争指数智慧应用却是最高的（大家的想法都一样hh），不过后面还是头铁上了（懒得改了），结果到最后统计的时候智慧应用反而只剩七个了（博弈论算是玩明白了）。\n上交（闵行）校门 因为上交和武大只隔了一天，因此在武汉多住一晚后直接从武汉出发赶往上海了。上交软院夏令营是在闵行校区，感觉特别偏僻，周围配套还不是很完善，地铁站离学校还有一段距离，但学校大是真的大。\n夏令营分为了两天，考核是常规的机试+面试，但是机试很不常规，非OJ，一道超大模拟题，可以带一些离线资料（然并卵），最后提交一个压缩包上去。第二天面试，老师都挺好的，不会过多刁难你，印象里问了好多问题，有数据结构，也有简历面，不过论文倒是一点没问（奇怪）。\n在面试完后，有老师打电话给我，说我面试还不错，问我是否考虑，我当即答应了下来。不过上交得到九月才出名额，后面到了被告知这个方向只有联培了，遂作罢。\n整体来说，感觉上交硕士的本校保护很厉害，无论是宣讲还是最后的给的名额，给外校的基本都只有联培的名额（并非说联培不好，叠甲）。但是软院的招生老师还是很好滴，无论是前期的通知还是后续打电话问是否接受联培名额，整体给人的感觉很亲切负责。\n科大网安\r科大是出了名的对号入座，非CS的很难入CS营，又因为网安大部分老师是从6系和CS那边调过来的，方向没这么偏向安全，因此就报了网安。 科大的夏令营感觉是全场最佳了，酒店、大礼包、一百块的饭卡，还有超级盛大的开营仪式，而且全程有志愿者对接，简直仪式感拉满！！\n无敌的仪式感 夏令营分为了三天，第一天就是学校和各个学院的介绍+合影。第二天则是实验室介绍，如果打算来科大的千万要抓住这个机会，这不仅仅是参观，还要趁此机会加心仪实验室的联系方式，主动交流占坑。第三天的面试分为了上下午两场，一场十分钟，区别在于是否有英文问题，感觉更多是走个过场，不会过深挖掘。\n科大基本人均优营，没有效力，需要和老师完成双选才是铁offer，建议提前联系好导师面试，强导基本在夏令营开始前就被占满了，并且科大的预推免基本没有名额，得看鸽子（今年网安鸽子很多，到929都还有坑位）。\n科大的夏令营真的办得很棒，食宿、文创什么的都拉满了（据说书包还被倒卖出去不少hh），最后也联系上了导师，不过因为后面拿到了清软的offer就主动释放了。\n浙大CAD\u0026amp;CG\r浙大根据实验室不同，安排的项目考核时长也相应不同，有的长达两个月，有的可能就一个多星期（比如我们），考核内容基本是以论文复现为主，竞争总体不会特别激烈，因为只有外校的，并且到后面很多都坚持不下去。\nCAD\u0026CG CAD\u0026CG是在紫金港，是真的又大又好看（别人家的学校），实验室的师兄师姐和老师也很nice！！不过后面把我专业调剂了，并且和个人的规划方向不太相同，主动释放了offer。 预推免情况\r夏令营在拿到科大和浙大的铁offer后，预推免就能更大胆些了，目标就主要是一些夏令营没能入营与清北两所了。\n院校 是否入营 是否优营 备注 哈工深cs学硕 否 否 hitsz你拒我两次555 清华软院专硕 是 是 最终去向 清华深圳专硕 否 否 它甚至发拒信，哭死 复旦cs学硕 是 否 开摆 北大软微 否 否 今年大部分要跟实验室课题了，头铁网安方向，寄 北大深圳 否 否 没有套磁，意料之中 南大ai学硕 否 否 南大se学硕 是 否 准备清软，放弃入营 清华软院专硕\r这是我的预一营，最初我就是抱着报来试试的心态，没想到能够顺利入营，那时候高兴的要起飞了。招生老师也超级好，虽然没有建群，但是基本有求必应，并且所有通知都是邮箱短信双提醒（赞）。\n入营邮件 清华的前期流程算是比较复杂的了，需要老师在线填写推荐信（真的感觉很不好意思），别的按照要求填上就好。\n清软的考核分为了两天，第一天机试，可以带参考资料，我带了AcWing的模板，一共三题，第一题打卡题，第二题我用了模板很快也AC了，最后一题实在是想不出来了，罚坐（有大佬一个半小时结束战斗xm）。第二天面试，老师们都特别和蔼，不会刻意刁难，虽然我英文题爆炸了（被cue了六级），但是老师还是没有过多为难。\n虽然机试20%+面试80%，但是我感觉面试大家的差距不会很大，反而机试十分重要，占比是主要的，我也难得幸运了一次（开心），也可能是自己本身放低了预期，没想着能够进入清华，心态比较好吧hh\n复旦CS学硕\r在拿了清软的offer后，复旦就没有过多去准备了，第一天机试（5题），第二天英文面试（甚至单拎出来，就五分钟，可能这天更多是联系导师吧），第三天就是专业面试了（问了超多专业课，根本不会，感觉要把老师题库问完了，一直在看结束没xs）\n9.29终章\r9.28填好系统后，9.29就等清华发offer啦，虽然比别的学校都要晚点hh，但是等待是值得的~\n上岸咯 个人总结\u0026amp;建议\r上圣经！！\n保研圣经 关于心态：在拿到清软offer前，其实一直没有一个满意的offer，总是差点意思，这也导致了夏令营和预推免这段空档我并不轻松，时常会做噩梦惊醒。因此，我认为放平心态十分重要，我身边既有夏0营但最后保研华五的，也有拿着一堆夏令营但最后去向一般的，夏令营20%的人掌握了80%的offer，但最终只能留下一个，复旦在十月份还在紧急扩散呢，策略不同势必会导致不同的入营情况，没有必要去刻意地对比，查漏补缺，针对性补充完全来得及。 关于提前进组：整个保研周期从夏令营到9.29大概三个月，不算长，但真正的准备可能从大三上就开始了，提前进组实习能够十分有效提高你在保研的竞争力，如果恰好是弱com，那直接提前锁定了。 关于入营：选择性入营，选择大于努力，参加过多营的弊端很明显，耗时耗精力，更是没有时间去停下来反思总结，十分考验个人的调整能力，适当的放弃能更全身心地准备梦校。 关于机试：算法很重要，我算法从大三下开始，把leetcode hot100三刷，又在夏令营和预推免之间的空窗期把AcWing基础算法课刷完，其实整体是有点赶的，建议还是尽早做准备，算法无法一蹴而就。 关于面试：可以准备好简历带过去，建议穿的干净一点，面试过程中不卑不亢，自信而不失谦逊，言语铿锵有力，不必担心老师会瞧不上你的科研，也不应频繁打断老师提问，张弛有度、彬彬有礼即可。 关于人品：我认为在9.29前如果有心仪且铁offer时，应该把其他的offer及时释放掉，尽可能少的影响老师的招生，也能将offer给到有需要的人。 结语\r没有什么根本来不及，种一棵树最好的时候是十年前，其次是现在，我们需要的是更多勇气。\n在这里，我要感谢一路帮助我的老师、学长、同学、朋友们，精辟独到的建议指引我正确的方向，我也要感恩一直以来支持和鼓励我的父母和女朋友，在我最需要的时候出现在我身边，支撑着我坚持到最后！\n","date":"2024-10-13T14:29:12+08:00","permalink":"https://leanmax.github.io/p/%E4%BF%9D%E7%A0%94%E5%9B%9E%E5%BF%86%E5%BD%95/","title":"保研回忆录"},{"content":"My First Blog\rJust memory my first blog. Nothing else~\n","date":"2024-10-11T21:03:48+08:00","permalink":"https://leanmax.github.io/p/my-first-post/","title":"My First Post"}]
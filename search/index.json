[{"content":"django内置的缓存机制？\rDjango 提供了一个内置的缓存框架，可以通过多种方式缓存页面、视图、查询结果或其他数据，以提高性能和减少数据库访问。Django 的缓存机制非常灵活，支持多种缓存后端，如内存、文件系统、数据库等。下面是 Django 内置缓存机制的主要部分：\n1. 缓存后端\rDjango 支持多种缓存后端，常见的包括：\n内存缓存（MemoryCache）：使用本地内存作为缓存存储，适合单机部署的小型项目。\n1 2 3 4 5 CACHES = { \u0026#39;default\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.core.cache.backends.locmem.LocMemCache\u0026#39;, } } 文件系统缓存（FileBasedCache）：将缓存存储在文件系统中，适合需要跨进程共享的缓存。\n1 2 3 4 5 6 CACHES = { \u0026#39;default\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.core.cache.backends.filebased.FileBasedCache\u0026#39;, \u0026#39;LOCATION\u0026#39;: \u0026#39;/var/tmp/django_cache\u0026#39;, } } 数据库缓存（DatabaseCache）：将缓存存储在数据库中，需要预先创建缓存表。\n1 2 3 4 5 6 CACHES = { \u0026#39;default\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.core.cache.backends.db.DatabaseCache\u0026#39;, \u0026#39;LOCATION\u0026#39;: \u0026#39;my_cache_table\u0026#39;, } } 创建缓存表：\n1 python manage.py createcachetable Memcached：一个高效的内存缓存系统，适合大规模部署的项目。\n1 2 3 4 5 6 CACHES = { \u0026#39;default\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.core.cache.backends.memcached.MemcachedCache\u0026#39;, \u0026#39;LOCATION\u0026#39;: \u0026#39;127.0.0.1:11211\u0026#39;, } } Redis：流行的键值存储，支持复杂的数据结构，适合高并发项目。\n1 2 3 4 5 6 CACHES = { \u0026#39;default\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django_redis.cache.RedisCache\u0026#39;, \u0026#39;LOCATION\u0026#39;: \u0026#39;redis://127.0.0.1:6379/1\u0026#39;, } } 2. 缓存的使用方式\rDjango 提供了多种级别的缓存控制方式，包括：\n（1）整个网站的缓存\r通过 CACHE_MIDDLEWARE_ALIAS 中间件配置，可以为整个网站启用缓存。\n1 2 3 4 5 6 7 MIDDLEWARE = [ \u0026#39;django.middleware.cache.UpdateCacheMiddleware\u0026#39;, # 在视图执行前缓存页面 # 其他中间件 \u0026#39;django.middleware.cache.FetchCacheMiddleware\u0026#39;, # 从缓存中获取页面 ] CACHE_MIDDLEWARE_SECONDS = 600 # 缓存600秒 CACHE_MIDDLEWARE_ALIAS = \u0026#39;default\u0026#39; # 使用默认的缓存配置 （2）视图级缓存\r你可以为某个视图单独设置缓存，使用 @cache_page 装饰器。\n1 2 3 4 5 6 from django.views.decorators.cache import cache_page @cache_page(60 * 15) # 缓存15分钟 def my_view(request): # 视图逻辑 return render(request, \u0026#39;my_template.html\u0026#39;) （3）模板片段缓存\r对于一些昂贵的计算或数据库查询，你可以缓存模板的某个片段，而不是整个页面。使用 cache 模板标签。\n1 2 3 4 {% load cache %} {% cache 600 sidebar %} \u0026lt;!-- 这里是一些昂贵的查询和模板渲染逻辑 --\u0026gt; {% endcache %} （4）手动缓存控制\r你可以使用 Django 的 cache 模块手动控制缓存的存取。常见操作包括：\n设置缓存：\n1 2 from django.core.cache import cache cache.set(\u0026#39;my_key\u0026#39;, \u0026#39;my_value\u0026#39;, timeout=60) # 缓存60秒 获取缓存：\n1 value = cache.get(\u0026#39;my_key\u0026#39;) 删除缓存：\n1 cache.delete(\u0026#39;my_key\u0026#39;) 检查缓存是否存在：\n1 2 if cache.has_key(\u0026#39;my_key\u0026#39;): # 做某些操作 3. 缓存失效和超时\rTimeout（超时）：你可以为缓存设置超时，当超时到期后，缓存内容会自动失效并删除。通过 timeout 参数设置缓存时长，默认为全局的超时时间，也可以在 set() 方法中单独指定。\nKey-based Invalidations（基于键的失效）：当你需要主动失效缓存时，可以通过 delete() 方法手动删除缓存条目。\n4. 缓存版本控制\rDjango 还支持缓存的版本控制功能，这在你想要统一刷新缓存时很有用。通过 cache.set() 和 cache.get() 的 version 参数可以指定缓存版本。\n5. 基于数据库查询的缓存\rDjango ORM 通过缓存框架可以缓存某些昂贵的数据库查询结果。比如，手动缓存查询结果：\n1 2 3 4 5 # 缓存查询结果 results = cache.get(\u0026#39;my_query\u0026#39;) if not results: results = MyModel.objects.filter(field=\u0026#39;value\u0026#39;) cache.set(\u0026#39;my_query\u0026#39;, results, timeout=300) 6. SESSION 缓存\rDjango 也支持将用户的 session 存储在缓存中，提升 session 的读写性能。\n1 2 SESSION_ENGINE = \u0026#39;django.contrib.sessions.backends.cache\u0026#39; SESSION_CACHE_ALIAS = \u0026#39;default\u0026#39; # 使用默认缓存配置 总结\rDjango 内置缓存框架支持多种缓存后端（内存、文件、数据库、Memcached、Redis等）。 提供了全局、视图、模板片段和手动缓存控制方式。 可以通过信号和钩子函数实现缓存的自动化管理。 缓存超时、失效和版本控制使得缓存机制更加灵活。 django的缓存能使用redis吗？如果可以的话，如何配置？\r是的，Django 支持使用 Redis 作为缓存后端。Redis 是一个高性能的键值数据库，广泛用于缓存、消息队列等场景。Django 内置的缓存框架可以轻松配置为使用 Redis 来存储缓存数据。\n配置步骤如下：\r1. 安装依赖包\r首先，你需要安装 django-redis 这个库，它是 Django 使用 Redis 作为缓存后端的常用库。\n1 pip install django-redis 2. 修改 Django 的缓存配置\r在 settings.py 文件中，配置缓存使用 Redis 作为后端。以下是一个常见的 Redis 缓存配置示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 CACHES = { \u0026#39;default\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django_redis.cache.RedisCache\u0026#39;, # 使用django-redis提供的RedisCache后端 \u0026#39;LOCATION\u0026#39;: \u0026#39;redis://127.0.0.1:6379/1\u0026#39;, # Redis的连接地址，IP、端口和数据库编号 \u0026#39;OPTIONS\u0026#39;: { \u0026#39;CLIENT_CLASS\u0026#39;: \u0026#39;django_redis.client.DefaultClient\u0026#39;, # 客户端类 # 其他可选配置，例如序列化器 \u0026#39;SERIALIZER\u0026#39;: \u0026#39;django_redis.serializers.json.JSONSerializer\u0026#39;, # 使用JSON序列化 # \u0026#39;PASSWORD\u0026#39;: \u0026#39;your_redis_password\u0026#39;, # 如果Redis设置了密码，可以在这里添加 }, \u0026#39;TIMEOUT\u0026#39;: 300, # 默认缓存过期时间，单位为秒 \u0026#39;KEY_PREFIX\u0026#39;: \u0026#39;myapp\u0026#39;, # 缓存键的前缀，避免键冲突 } } 配置选项解释：\rBACKEND: 指定缓存后端为 django_redis.cache.RedisCache，这是 django-redis 提供的缓存后端。 LOCATION: 指定 Redis 的连接地址，例如 redis://127.0.0.1:6379/1 表示连接到本地的 Redis，使用数据库编号 1。 OPTIONS: CLIENT_CLASS: 使用 django_redis.client.DefaultClient 来处理 Redis 的客户端连接。 SERIALIZER: 指定序列化器，例如这里使用 JSON 序列化器。默认情况下使用 pickle 序列化器。 PASSWORD: 如果 Redis 服务器设置了密码，可以在此指定密码。 TIMEOUT: 设置缓存过期时间（单位：秒），可以根据需求调整。 KEY_PREFIX: 在 Redis 缓存的键名之前加上前缀，防止不同项目间的缓存键冲突。 3. 测试 Redis 缓存\r你可以在项目中测试缓存是否正常工作，例如：\n1 2 3 4 5 6 7 8 from django.core.cache import cache # 设置缓存 cache.set(\u0026#39;my_key\u0026#39;, \u0026#39;my_value\u0026#39;, timeout=60) # 缓存60秒 # 获取缓存 value = cache.get(\u0026#39;my_key\u0026#39;) print(value) # 输出：my_value 如果配置正确，Redis 将开始存储和管理缓存数据。你可以使用 Redis CLI 工具查看缓存的键值：\n1 redis-cli 在 Redis CLI 中，执行 KEYS * 查看 Redis 中所有的缓存键。\n4. 额外选项\r集群：如果你使用的是 Redis 集群，可以使用 django_redis.client.HerdClient 或 ShardedClient 作为 CLIENT_CLASS。\n持久化连接：可以通过 OPTIONS 配置持久化连接来提升性能，例如：\n1 2 3 4 \u0026#39;OPTIONS\u0026#39;: { \u0026#39;CONNECTION_POOL_KWARGS\u0026#39;: {\u0026#39;max_connections\u0026#39;: 100}, \u0026#39;CONNECTION_TIMEOUT\u0026#39;: 20, } 5. Session 缓存\r你也可以将用户会话存储在 Redis 中，提高会话读写性能。配置如下：\n1 2 SESSION_ENGINE = \u0026#39;django.contrib.sessions.backends.cache\u0026#39; SESSION_CACHE_ALIAS = \u0026#39;default\u0026#39; # 使用上面配置的Redis缓存 总结\r通过 django-redis 库，Django 能够轻松使用 Redis 作为缓存后端。只需在 settings.py 中配置 CACHES 变量，并确保安装了 django-redis 和 redis 服务器。\nReferences\rpython web框架django面试题 django的模板中filter和simple_tag的区别？ django-debug-toolbar的作用？ django中如何实现单元测试？ django中如何根据数据库表生成model中的类？ django的contenttype组件的作用？ 谈谈你对restful规范的认识？ 接口的幂等性是什么意思？ 什么是RPC？ 为什么要使用API 为什么要使用django rest framework框架？ django rest framework框架中都有那些组件？ django rest framework框架中的视图都可以继承哪些类？ 简述 django rest framework框架的认证流程 django rest framework如何实现的用户访问频率控制 rest_framework序列化组件的作用,以及一些外键关系的钩子方法 给用户提供一个接口之前需要提前做什么 PV和UV 什么是跨域以及解决方法: 如何实现用户的登陆认证 如何将dict转换成url的格式： ","date":"2024-10-15T17:48:09+08:00","permalink":"http://localhost:1313/p/django%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9B%9B/","title":"Django面试题（四）"},{"content":"django的Form和ModeForm的作用？\rDjango的Form和ModelForm是框架中非常重要的两个组件，主要用于处理表单数据和数据模型。以下是它们的具体作用：\n1. Django Form：\r生成页面可用的HTML标签：Form类可以自动生成HTML表单代码，使得在前端页面中能够方便地展示表单。 **对用户提交的数据进行校验：**Form类可以对用户提交的数据进行各种验证，确保数据的合法性和正确性。这可以防止恶意用户提交非法数据或进行攻击。 保留上次输入内容：如果用户提交的数据验证不通过，Form类可以保留用户上次输入的内容，方便用户进行修改后再次提交。 2. Django ModelForm：\r继承自Form类：ModelForm是Form的子类，因此它具有Form类的所有功能，包括生成HTML标签、数据验证等。 与数据模型进行绑定：ModelForm与Django的数据模型进行绑定，可以直接对数据库表进行操作。这使得在表单处理过程中，可以方便地读取、修改、删除数据库中的数据。 自动生成表单字段：根据绑定的数据模型，ModelForm可以自动生成对应的表单字段，无需手动定义。这大大简化了表单的开发过程。 django的Form组件中,如果字段中包含choices参数，请使用两种方式实现数据源实时更新。\r1. 重写Form类的__init__方法\r可以通过重写Form类的__init__方法来动态地设置字段的choices。这通常涉及到从数据库或其他外部源获取数据，并将其作为字段选项。\n1 2 3 4 5 6 7 8 9 10 11 12 from django import forms from .models import MyModel class MyForm(forms.Form): my_field = forms.ChoiceField(choices=[]) # 初始为空，稍后在__init__中填充 def __init__(self, *args, **kwargs): super(MyForm, self).__init__(*args, **kwargs) # 从数据库或其他地方获取数据 choices = MyModel.objects.values_list(\u0026#39;id\u0026#39;, \u0026#39;name\u0026#39;) # 更新字段的choices self.fields[\u0026#39;my_field\u0026#39;].choices = choices 2. 使用ModelChoiceField\r如果你的选项来自于一个Django模型，你可以使用ModelChoiceField，它允许你指定一个查询集（QuerySet）作为选项。你可以在Form类中定义一个方法来返回查询集，并在ModelChoiceField中使用这个方法。\n1 2 3 4 5 6 7 8 9 10 11 12 from django import forms from .models import MyModel class MyForm(forms.Form): def get_my_choices(): # 返回查询集 return MyModel.objects.all() my_field = forms.ModelChoiceField(queryset=get_my_choices()) # 注意：上面的代码片段有一个问题，即`get_my_choices`在类定义时被调用，而不是在实例化时。 # 正确的做法是使用lambda表达式或者将查询集定义在__init__方法中。 然而，上面的代码片段有一个问题：get_my_choices在类定义时就被调用了，而不是在实例化时。这会导致每次服务器启动时获取一次选项，而不是每次请求时。为了解决这个问题，你应该在__init__方法中设置查询集：\n1 2 3 4 5 6 7 8 9 10 from django import forms from .models import MyModel class MyForm(forms.Form): my_field = forms.ModelChoiceField(queryset=MyModel.objects.none()) # 初始设置为空的查询集 def __init__(self, *args, **kwargs): super(MyForm, self).__init__(*args, **kwargs) # 在实例化时更新查询集 self.fields[\u0026#39;my_field\u0026#39;].queryset = MyModel.objects.all() 在这个修正后的例子中，MyModel.objects.none()创建了一个空的查询集，它在数据库中没有匹配任何记录。然后，在__init__方法中，我们根据实际需要更新了查询集。\n推荐使用第二种方式，因为它直接与Django的ORM集成，可以更容易地处理数据库查询和相关的优化。同时，确保在__init__方法中设置或更新查询集，以确保每次表单实例化时都能获取到最新的数据。\ndjango的Model中的ForeignKey字段中的on_delete参数有什么作用？\r在 Django 的 Model 中，ForeignKey 字段的 on_delete 参数用于指定当关联的外键对象被删除时，当前对象应该如何处理。这是为了确保在外键引用被删除时，数据库的完整性得到维护。\n常见的 on_delete 行为选项\r以下是 on_delete 参数的几种常见选项，它们对应不同的处理方式：\nCASCADE：\n行为：级联删除。当外键关联的对象被删除时，所有引用该对象的记录也会被删除。 使用场景：适用于依赖外键对象存在的子对象。比如：订单删除时，同时删除所有相关的订单明细。 示例： 1 2 3 4 5 6 class Author(models.Model): name = models.CharField(max_length=100) class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, on_delete=models.CASCADE) 如果某个 Author 被删除，那么所有与该 Author 相关联的 Book 记录也会被删除。 PROTECT：\n行为：阻止删除。当尝试删除外键对象时，抛出 ProtectedError 异常，从而阻止删除操作。 使用场景：适用于你希望确保外键引用的对象不会被删除，除非先删除所有相关的依赖对象。 示例： 1 2 3 class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, on_delete=models.PROTECT) 如果某个 Author 关联了 Book，试图删除该 Author 会抛出异常，阻止删除操作。 SET_NULL：\n行为：将外键字段设置为 NULL。需要指定 null=True，否则会引发错误。 使用场景：当外键对象被删除时，当前对象的外键字段可以为空，保持记录存在但移除外键关联。 示例： 1 2 3 class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, on_delete=models.SET_NULL, null=True) 如果某个 Author 被删除，相关的 Book 记录不会被删除，但 author 字段会被设置为 NULL。 SET_DEFAULT：\n行为：将外键字段设置为默认值。需要设置 default 参数。 使用场景：当外键对象被删除时，当前对象的外键字段被重置为一个默认值。 示例： 1 2 3 class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, on_delete=models.SET_DEFAULT, default=1) 如果某个 Author 被删除，相关的 Book 的 author 字段会被设置为默认值（比如 id=1 的 Author）。 SET()：\n行为：调用传入的函数或指定的值来设置外键字段。可以自定义字段的设置行为。 使用场景：适用于复杂的场景，当你需要更灵活的方式来处理删除外键时的字段设置。 示例： 1 2 3 class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, on_delete=models.SET(some_function)) 当 Author 被删除时，some_function 会被调用来设置 author 字段。 DO_NOTHING：\n行为：不做任何处理。Django 不会干预，但可能会违反数据库的外键约束，导致数据库层抛出错误。 使用场景：适用于你在数据库层面手动处理删除外键的逻辑。 示例： 1 2 3 class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, on_delete=models.DO_NOTHING) 如果 Author 被删除，Book 不会有任何变化，但如果数据库有外键约束，可能会抛出错误。 选择合适的 on_delete 选项\r级联删除 (CASCADE)：适合父子关系，删除父对象时自动删除所有子对象。 阻止删除 (PROTECT)：适合不允许删除父对象的场景。 设置为 NULL (SET_NULL)：适合允许子对象存在但取消外键关系的场景。 设置为默认值 (SET_DEFAULT)：适合需要重置外键字段为默认值的情况。 自定义设置 (SET())：适合需要灵活控制字段的更新逻辑时。 不做处理 (DO_NOTHING)：适合手动控制外键删除逻辑，通常需要自己处理异常。 总结\ron_delete 参数为你提供了多种处理外键删除的方式。选择合适的方式取决于你希望当外键对象被删除时，数据库中的相关数据如何处理，从而确保数据的完整性和业务逻辑的正确性。\n列举django orm中三种能写sql语句的方法。\r在 Django ORM 中，虽然 ORM 提供了高级的查询接口，但有时需要直接执行 SQL 语句。Django 提供了三种常见的方式可以编写和执行 SQL 语句：\n1. raw() 方法\r描述：用于执行原生 SQL 查询，并返回模型实例。可以将原生 SQL 语句与 Django 模型结合使用。\n适用场景：适用于复杂的查询或无法通过 ORM 生成的 SQL 查询。\n示例：\n1 2 3 4 5 6 7 8 class Book(models.Model): title = models.CharField(max_length=100) author = models.ForeignKey(Author, on_delete=models.CASCADE) # 使用 raw() 执行原生 SQL 查询 books = Book.objects.raw(\u0026#39;SELECT * FROM myapp_book WHERE author_id = %s\u0026#39;, [1]) for book in books: print(book.title) 注意：raw() 返回的对象是模型实例，但不能使用 raw() 来进行插入、更新或删除操作。\n2. Manager.raw() 方法\r描述：从模型管理器执行原生 SQL 查询。类似于 raw()，但是在模型的 Manager 上调用，返回查询结果集。 适用场景：当你想在模型管理器中定义自定义查询时使用（可用作默认查询）。 示例： 1 2 3 4 5 6 7 8 9 10 11 12 class BookManager(models.Manager): def with_custom_sql(self): return self.raw(\u0026#39;SELECT * FROM myapp_book WHERE title LIKE %s\u0026#39;, [\u0026#39;%Django%\u0026#39;]) class Book(models.Model): title = models.CharField(max_length=100) objects = BookManager() # 使用自定义的 Manager 来执行 SQL 查询 books = Book.objects.with_custom_sql() for book in books: print(book.title) 3. connection.cursor() 方法\r描述：直接使用数据库游标执行任意 SQL 语句。可以执行 SELECT、INSERT、UPDATE、DELETE 等操作，返回结果集或影响的行数。\n适用场景：适合需要执行任意 SQL 语句，或者执行不返回模型实例的操作（如批量插入、更新、删除等）。\n示例：\n1 2 3 4 5 6 7 8 9 from django.db import connection # 使用 cursor() 执行自定义 SQL 语句 with connection.cursor() as cursor: cursor.execute(\u0026#39;SELECT * FROM myapp_book WHERE author_id = %s\u0026#39;, [1]) rows = cursor.fetchall() # 返回所有查询结果 for row in rows: print(row) 注意：cursor() 提供了直接操作数据库的能力，但需要手动处理返回的数据，查询结果不会映射为模型实例。\n总结表格\r方法 作用 场景 示例 raw() 执行原生 SQL 并返回模型实例 查询复杂的或无法通过 ORM 实现的查询 Book.objects.raw('SELECT * FROM myapp_book') Manager.raw() 在模型管理器中自定义查询 自定义模型管理器中的复杂 SQL 查询 Book.objects.with_custom_sql() connection.cursor() 使用游标执行任意 SQL 执行任意 SQL（包括查询、插入、更新、删除等操作） cursor.execute('SELECT * FROM myapp_book') 这三种方式允许开发者根据需求灵活执行原生 SQL 语句，尤其是在 ORM 难以实现或性能要求较高的场景下，显得尤为重要。\ndjango orm 中如何设置读写分离？\r在 Django 中实现读写分离（即将读操作与写操作分离到不同的数据库实例）通常通过配置多个数据库、并根据操作类型（读或写）路由请求到相应的数据库。Django 的数据库路由机制允许开发者自定义逻辑来决定某个查询应该发送到哪个数据库。\n实现读写分离的步骤\r配置多个数据库\n在 settings.py 文件中配置多个数据库。通常，一个主数据库用于写操作（default），一个或多个从数据库用于读操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.postgresql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;main_db\u0026#39;, \u0026#39;USER\u0026#39;: \u0026#39;db_user\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;password\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;main_db_host\u0026#39;, \u0026#39;PORT\u0026#39;: \u0026#39;5432\u0026#39;, }, \u0026#39;replica\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.postgresql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;replica_db\u0026#39;, \u0026#39;USER\u0026#39;: \u0026#39;db_user\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;password\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;replica_db_host\u0026#39;, \u0026#39;PORT\u0026#39;: \u0026#39;5432\u0026#39;, }, } 自定义数据库路由\n使用数据库路由来确定读请求（SELECT）应该发送到从数据库，而写请求（INSERT、UPDATE、DELETE）发送到主数据库。通过创建一个自定义路由器类来实现该逻辑。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class DatabaseRouter: \u0026#34;\u0026#34;\u0026#34; A router to control all database operations on models. \u0026#34;\u0026#34;\u0026#34; def db_for_read(self, model, **hints): \u0026#34;\u0026#34;\u0026#34; Attempts to read go to the replica. \u0026#34;\u0026#34;\u0026#34; return \u0026#39;replica\u0026#39; # 所有读操作都路由到从数据库 def db_for_write(self, model, **hints): \u0026#34;\u0026#34;\u0026#34; Attempts to write go to the default database. \u0026#34;\u0026#34;\u0026#34; return \u0026#39;default\u0026#39; # 所有写操作都路由到主数据库 def allow_relation(self, obj1, obj2, **hints): \u0026#34;\u0026#34;\u0026#34; Allow relations if a model in the default or replica database is involved. \u0026#34;\u0026#34;\u0026#34; db_list = (\u0026#39;default\u0026#39;, \u0026#39;replica\u0026#39;) if obj1._state.db in db_list and obj2._state.db in db_list: return True return None def allow_migrate(self, db, app_label, model_name=None, **hints): \u0026#34;\u0026#34;\u0026#34; Ensure that all models end up in the default database. \u0026#34;\u0026#34;\u0026#34; return db == \u0026#39;default\u0026#39; # 迁移只在主数据库上进行 然后，在 settings.py 中注册该路由器。 1 DATABASE_ROUTERS = [\u0026#39;path.to.DatabaseRouter\u0026#39;] 选择性地使用数据库\nDjango ORM 默认使用路由规则来决定数据库，但在某些情况下，开发者可能想显式指定使用哪个数据库。可以通过 using() 方法选择数据库。 1 2 3 4 5 6 # 从数据库中读取 books = Book.objects.using(\u0026#39;replica\u0026#39;).all() # 向主数据库中写入 new_book = Book(title=\u0026#34;Django Tips\u0026#34;) new_book.save(using=\u0026#39;default\u0026#39;) 读写事务管理\n在使用多个数据库时，需要确保事务是按照操作类型在正确的数据库上进行。例如，读事务应该发生在从库，写事务应该发生在主库。 1 2 3 4 5 6 7 8 9 from django.db import transaction # 在主数据库上执行写操作 with transaction.atomic(using=\u0026#39;default\u0026#39;): Book.objects.create(title=\u0026#34;New Book\u0026#34;) # 在从数据库上执行读操作 with transaction.atomic(using=\u0026#39;replica\u0026#39;): books = Book.objects.all() 多数据库一致性问题\n在读写分离的架构中，由于主从复制的延迟，可能存在主库写入的数据还未同步到从库的情况。这时，从库的读操作可能读不到最新的数据。 解决方案之一是使用某种机制确保特定情况下（如立即读取刚刚写入的数据）从主库读取，或者通过更复杂的路由逻辑来处理这些场景。 小结\r通过配置多个数据库并自定义数据库路由，Django 可以实现读写分离。读操作通常路由到从库，而写操作路由到主库，从而分散数据库负载并提高系统的可扩展性。在实现读写分离时，需要注意主从数据库的同步延迟问题，并根据实际应用场景调整数据库路由的逻辑。\ndjango中如何实现orm表中添加数据时创建一条日志记录。\r在 Django 中，你可以通过多种方式在 ORM 表中添加数据时创建一条日志记录。一个常见的解决方案是使用 Django 的信号 或 重写模型的 save() 方法，在数据创建或更新时自动记录日志。\n方案 1：使用 Django 信号 (signals)\rDjango 提供了 signals，你可以监听模型的 post_save 信号来在数据保存后记录日志。\n步骤\r定义信号处理器： 你可以定义一个信号处理器，在模型保存时触发日志记录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from django.db.models.signals import post_save from django.dispatch import receiver import logging from .models import MyModel # 导入你的模型 # 设置日志记录器 logger = logging.getLogger(__name__) @receiver(post_save, sender=MyModel) def log_model_save(sender, instance, created, **kwargs): if created: logger.info(f\u0026#39;New record created: {instance}\u0026#39;) else: logger.info(f\u0026#39;Record updated: {instance}\u0026#39;) 连接信号： 在应用的 apps.py 中连接信号，确保应用启动时加载信号处理器。\n1 2 3 4 5 6 7 from django.apps import AppConfig class MyAppConfig(AppConfig): name = \u0026#39;myapp\u0026#39; def ready(self): import myapp.signals # 确保 signals.py 文件被加载 配置日志： 确保你的 Django 项目中已经正确配置了日志功能，通常是在 settings.py 中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 LOGGING = { \u0026#39;version\u0026#39;: 1, \u0026#39;disable_existing_loggers\u0026#39;: False, \u0026#39;handlers\u0026#39;: { \u0026#39;console\u0026#39;: { \u0026#39;class\u0026#39;: \u0026#39;logging.StreamHandler\u0026#39;, }, }, \u0026#39;loggers\u0026#39;: { \u0026#39;django\u0026#39;: { \u0026#39;handlers\u0026#39;: [\u0026#39;console\u0026#39;], \u0026#39;level\u0026#39;: \u0026#39;INFO\u0026#39;, }, \u0026#39;myapp\u0026#39;: { \u0026#39;handlers\u0026#39;: [\u0026#39;console\u0026#39;], \u0026#39;level\u0026#39;: \u0026#39;INFO\u0026#39;, \u0026#39;propagate\u0026#39;: False, }, }, } 效果： 当你在数据库中创建或更新 MyModel 的实例时，Django 会自动在日志中记录一条新创建或更新的消息。\n方案 2：重写模型的 save() 方法\r另一种方式是直接在模型的 save() 方法中加入日志记录逻辑，每次调用 save() 时记录日志。\n步骤\r重写模型的 save() 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import logging from django.db import models logger = logging.getLogger(__name__) class MyModel(models.Model): name = models.CharField(max_length=100) description = models.TextField() def save(self, *args, **kwargs): # 判断是创建还是更新 if self.pk is None: logger.info(f\u0026#39;Creating new record: {self}\u0026#39;) else: logger.info(f\u0026#39;Updating record: {self}\u0026#39;) # 调用父类的 save 方法，确保数据保存 super(MyModel, self).save(*args, **kwargs) 效果：\n在每次保存时，save() 方法都会被调用。日志记录器会自动判断当前操作是创建新记录还是更新已有记录，并相应地写入日志。 方案 3：使用数据库表记录日志\r如果你希望将日志存储在数据库中，而不是日志文件中，你可以创建一个日志模型，手动在 save() 方法或信号中记录每次操作的详细信息。\n步骤\r创建日志模型：\n1 2 3 4 5 6 7 8 9 10 11 from django.db import models class LogEntry(models.Model): action = models.CharField(max_length=100) model_name = models.CharField(max_length=100) object_id = models.IntegerField() timestamp = models.DateTimeField(auto_now_add=True) details = models.TextField() def __str__(self): return f\u0026#39;{self.action} on {self.model_name} (ID: {self.object_id}) at {self.timestamp}\u0026#39; 在 save() 方法中创建日志记录：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MyModel(models.Model): name = models.CharField(max_length=100) description = models.TextField() def save(self, *args, **kwargs): # 判断创建还是更新 action = \u0026#39;Created\u0026#39; if self.pk is None else \u0026#39;Updated\u0026#39; super(MyModel, self).save(*args, **kwargs) # 保存模型数据 # 创建日志记录 LogEntry.objects.create( action=action, model_name=self.__class__.__name__, object_id=self.pk, details=f\u0026#39;{action} record: {self}\u0026#39; ) 效果：\n每次模型保存时，日志模型会保存一条记录，记录操作类型（创建或更新）、模型名称、对象 ID 以及详细信息。 总结\r使用 Django 信号：适合解耦逻辑的方式，不需要修改模型类代码，可以针对所有模型统一记录日志。 重写 save() 方法：直接在模型中控制日志记录，简单且有效，适合某些特定模型的日志需求。 数据库日志：如果希望在数据库中保存操作日志，使用一个日志模型可以轻松管理所有记录。 你可以根据实际需求选择合适的方法来实现 Django ORM 表数据变更时的日志记录。\n解释orm中 db first 和 code first的含义？\r在ORM（Object Relational Mapping，对象关系映射）中，“db first”和“code first”是两种开发模式，用于处理数据库和应用程序代码之间的关系。\ndb first（数据库优先）：\r含义：这种模式首先从设计数据库开始。开发者会先创建数据库，包括定义表、字段、关系等，然后使用ORM工具根据已存在的数据库结构生成相应的数据模型类。这种方式的好处是数据库设计可以独立于应用程序代码，数据库管理员（DBA）可以专注于优化数据库性能，而开发者可以专注于编写应用程序逻辑。 应用：适用于那些数据库已经存在，且需要在其上构建应用程序的场景。例如，企业可能已经有了一个经过优化的数据库，现在需要开发一个新的Web应用程序来访问这个数据库。 code first（代码优先）：\r含义：与“db first”相反，“code first”模式强调从编写代码开始。开发者首先定义数据模型类（通常是C#、Java等语言的类），然后使用ORM工具根据这些类自动生成数据库结构。这种方式的好处是开发者可以专注于编写面向对象的代码，而不需要过多关注数据库的具体实现细节。ORM工具会自动处理数据库结构的创建和更新。 应用：适用于从零开始开发应用程序，且需要快速迭代和灵活调整数据库结构的场景。例如，初创公司可能需要快速开发一个MVP（最小可行产品），并根据用户反馈不断调整数据库结构。 在实际开发中，选择“db first”还是“code first”取决于具体需求和团队偏好。有些项目可能会混合使用这两种模式，以获得最佳的开发效率和数据库性能。\n使用orm和原生sql的优缺点？\r类别 优点 缺点 ORM 简化开发流程：ORM框架使得开发者无需编写复杂的SQL语句，从而简化了开发流程。\n提高代码可读性：ORM框架隐藏了底层数据库的实现细节，使得代码更加清晰易懂。\n易用性：可以有效减少重复SQL，提供了基础的CRUD操作、多表关联查询、事务控制、钩子函数等功能。\n移植性好：ORM框架可以轻松地切换不同的数据库，而无需修改大量的SQL语句。 学习成本高：需要掌握ORM框架的API和概念，有一定的学习成本。\n可能影响查询性能：ORM框架在查询数据时可能会产生额外的开销，导致查询性能下降。\n复杂数据模型处理有限：对于复杂的数据模型，ORM框架的性能和可靠性可能受到限制。\n原生SQL 灵活性：原生SQL提供了灵活的查询语法，可以精确控制数据访问，满足各种复杂查询需求。\n性能优势：对于大量数据的处理，原生SQL的性能通常优于ORM框架。\n直接操作数据库：原生SQL可以直接操作数据库，避免ORM框架可能产生的额外开销。 编写和维护成本高：需要手写SQL语句，并对其进行维护，有一定的编写和维护成本。\n数据库依赖性：SQL语句通常针对特定的数据库编写，切换数据库时需要修改SQL语句。\n代码可读性差：相比ORM框架，原生SQL的代码可读性较差，不易于理解和维护。 References\rpython web框架django面试题 Django的Form和ModeForm的作用？ ","date":"2024-10-15T15:17:09+08:00","permalink":"http://localhost:1313/p/django%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%89/","title":"Django面试题（三）"},{"content":"django的request对象是在什么时候创建的？\r当请求一个页面时, Django会建立一个包含请求元数据的HttpRequest对象。\n当Django加载对应的视图时, HttpRequest对象将作为视图函数的第一个参数，另外每个视图会返回一个HttpResponse对象。\nDjango重定向是如何实现的？用的什么状态码？\r使用HttpResponseRedirect 1 2 3 4 5 6 7 from django.http import HttpResponseRedirect def update_time(request): # 表单处理 OR 逻辑处理 return HttpResponseRedirect(\u0026#39;/\u0026#39;) #跳转到主界面 # 如果需要传参数 # return HttpResponseRedirect(\u0026#39;/commons/index/?message=error\u0026#39;) redirect 和 reverse 1 2 3 4 5 6 7 8 9 10 11 from django.core.urlresolvers import reverse from django.shortcuts import redirect def update_time(request): # 进行要处理的逻辑 return redirect(reverse(\u0026#39;test.views.invoice_return_index\u0026#39;, args=[])) # 跳转到index界面 # redirect 类似HttpResponseRedirect的用法， # 也可以使用 字符串的url格式 /..index/？a=add # reverse 可以直接用views函数来指定重定向的处理函数，args是url匹配的值。 状态码：301和302\n相同点：都表示重定向，浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址 不同点： 301比较常用的场景是使用域名跳转。比如，我们访问 http://www.baidu.com 会跳转到 https://www.baidu.com，表示旧地址A的资源已经被永久地移除了 302用来做临时跳转，比如未登陆的用户访问用户中心重定向到登录页面。表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B django中csrf的实现机制\r跨站请求伪造（CSRF，Cross-Site Request Forgery）是一种攻击方式，攻击者诱导用户在已认证的网站上执行非授权操作。攻击者通常通过第三方网站发送恶意请求，让受害者在不知情的情况下使用其已登录的身份发起请求，执行操作。（攻击者可以利用Cookie但不能获取Cookie）\ndjango通过’django.middleware.csrf.CsrfViewMiddleware’这个中间层来完成。\n具体机制：\n用户第一次访问网站时，Django 在响应中生成一个 CSRF Token，并将其存储在 csrftoken Cookie 中。 当用户提交表单时，CSRF Token 被嵌入到表单的隐藏字段中，同时被发送到服务器。 Django 的 CSRF 中间件接收请求后，验证表单中的 Token 和 Cookie 中的 Token 是否匹配。\n如果验证成功，请求通过；如果失败，返回 403 错误。 基于django使用ajax发送post请求时，都可以使用哪种方法携带csrf token？\r将 CSRF Token 添加到请求头：推荐使用 X-CSRFToken，这种方式最常用且最安全。 将 CSRF Token 作为 POST 数据的一部分：适用于需要通过 FormData 提交文件的场景。 Django本身提供了runserver，为什么不能用来部署？(runserver与uWSGI的区别)\rrunserver 是调试 Django 时经常用到的运行方式，它使用 Django 自带的 WSGI Server 运行，主要在测试和开发中使用，并且 runserver 开启的方式也是单进程。 uWSGI 是一个 Web 服务器，它实现了WSGI，uwsgi，HTTP等协议。uwsgi 是一种通信协议，而 uWSGI 是实现 uwsgi 协议和 WSGI 协议的 Web 服务器。uWSGI 具有超快的性能、低内存占用等优点，并且搭配着 Nginx 组成项目的生产环境，能够将用户访问请求与项目应用隔离，实现真正的网站部署。相对来说，这种方式支持的并发量更高，方便管理多进程，发挥多核的优势，提升性能。 cookie和session的区别\r1. 存储位置与数据安全性\rCookie：存储在客户端浏览器中，数据安全性相对较差。因为数据保存在客户端浏览器中，如果用户或第三方工具非法获取Cookie内容，可能导致数据泄露或身份冒用。 Session：数据保存在服务器端，安全性相对较高。因为数据存储在服务器端，可以有效防止数据被非法获取或篡改。 2. 存取方式与数据类型\rCookie：只能保存ASCII字符，因此无法直接存储复杂数据类型，通常用于存储简单的标识信息，如会话ID、用户偏好等。 Session：可以保存任意数据类型，如字符串、数字、对象等。因此，Session可以用于存储更复杂的用户数据，如用户购物车信息、个性化设置等。 3. 有效期与生命周期\rCookie：有效期取决于设置的Expires属性或Max-Age属性，通常在浏览器会话结束时过期（即关闭浏览器时）。另外，用户也可以通过禁用Cookie来影响Cookie的有效期。 Session：有效期通常由服务器配置决定，Session的生命周期通常由服务器清理过期或未活动的会话来管理。 4. 跨域请求与分布式处理\rCookie：由于同源策略的限制，Cookie无法在跨域请求中使用。这意味着如果一个网站需要从其他域获取资源或服务，将无法使用Cookie进行身份验证或会话管理。 Session：在跨域请求中，可以通过将Session存储在中央服务器或使用分布式Session来处理。这样可以在多个域之间共享用户会话信息，实现跨域认证和资源共享。 列举django orm 中所有的方法（QuerySet对象的所有方法）\r1. 查询方法\r这些方法用于检索和获取数据。\nall()：返回所有对象的 QuerySet。\n1 Person.objects.all() get()：根据条件返回单个对象，如果找不到对象或有多个对象匹配条件，则会抛出异常。\n1 Person.objects.get(id=1) filter()：根据条件过滤数据，返回一个新的 QuerySet。\n1 Person.objects.filter(age__gte=18) exclude()：排除符合条件的对象，返回一个新的 QuerySet。\n1 Person.objects.exclude(age__lt=18) first()：返回 QuerySet 中的第一个对象，如果没有对象则返回 None。\n1 Person.objects.filter(age__gte=18).first() last()：返回 QuerySet 中的最后一个对象，如果没有对象则返回 None。\n1 Person.objects.filter(age__gte=18).last() latest()：根据日期字段获取最新的对象（需要指定 get_latest_by）。\n1 Person.objects.latest(\u0026#39;created_at\u0026#39;) earliest()：根据日期字段获取最早的对象。\n1 Person.objects.earliest(\u0026#39;created_at\u0026#39;) exists()：检查是否存在符合条件的对象，返回 True 或 False。\n1 Person.objects.filter(age__gte=18).exists() count()：返回查询集中的对象数量。\n1 Person.objects.filter(age__gte=18).count() 2. 排序与限制\r这些方法用于排序和限制返回的结果。\norder_by()：对查询结果进行排序。\n1 2 Person.objects.order_by(\u0026#39;name\u0026#39;) # 升序 Person.objects.order_by(\u0026#39;-name\u0026#39;) # 降序 distinct()：去除查询结果中的重复记录。\n1 Person.objects.distinct(\u0026#39;name\u0026#39;) reverse()：对查询集的结果进行反转。\n1 Person.objects.all().reverse() values()：返回字典形式的查询结果（只返回指定字段）。\n1 Person.objects.values(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;) values_list()：返回元组形式的查询结果。\n1 Person.objects.values_list(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;) none()：返回一个空的 QuerySet。\n1 Person.objects.none() select_related()：用于一对多和一对一关系的表连接，减少查询次数。\n1 Person.objects.select_related(\u0026#39;profile\u0026#39;) prefetch_related()：用于多对多和反向查询的表连接。\n1 Person.objects.prefetch_related(\u0026#39;books\u0026#39;) only()：只加载指定的字段。\n1 Person.objects.only(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;) defer()：延迟加载指定的字段。\n1 Person.objects.defer(\u0026#39;bio\u0026#39;) select_for_update()：对数据行加锁（用于事务中）。\n1 Person.objects.select_for_update() 3. 聚合与注解\r这些方法用于统计和计算。\naggregate()：执行聚合查询（例如 Sum、Avg 等）。\n1 2 from django.db.models import Avg Person.objects.aggregate(Avg(\u0026#39;age\u0026#39;)) annotate()：在 QuerySet 中添加额外的计算字段。\n1 2 from django.db.models import Count Person.objects.annotate(num_books=Count(\u0026#39;books\u0026#39;)) 4. 更新与删除\r这些方法用于修改或删除数据库中的对象。\nupdate()：对符合条件的对象进行批量更新。\n1 Person.objects.filter(age__lt=18).update(age=18) delete()：删除符合条件的对象。\n1 Person.objects.filter(age__lt=18).delete() bulk_create()：批量创建对象，避免多次数据库写入。\n1 Person.objects.bulk_create([Person(name=\u0026#39;Alice\u0026#39;), Person(name=\u0026#39;Bob\u0026#39;)]) bulk_update()：批量更新对象。\n1 Person.objects.bulk_update([person1, person2], [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;]) 5. 高级查询\r这些方法用于执行更复杂的查询。\nextra()：执行自定义的 SQL 查询（不推荐使用，未来版本将弃用）。\n1 Person.objects.extra(select={\u0026#39;is_adult\u0026#39;: \u0026#39;age \u0026gt;= 18\u0026#39;}) raw()：执行原生 SQL 查询。\n1 Person.objects.raw(\u0026#39;SELECT * FROM myapp_person WHERE age \u0026gt;= %s\u0026#39;, [18]) union()：联合多个 QuerySet。\n1 2 3 qs1 = Person.objects.filter(age__gte=18) qs2 = Person.objects.filter(age__lt=18) qs1.union(qs2) intersection()：取多个 QuerySet 的交集。\n1 2 3 qs1 = Person.objects.filter(age__gte=18) qs2 = Person.objects.filter(age__lt=30) qs1.intersection(qs2) difference()：取多个 QuerySet 的差集。\n1 2 3 qs1 = Person.objects.filter(age__gte=18) qs2 = Person.objects.filter(age__lt=30) qs1.difference(qs2) 6. 缓存与清空\riterator()：逐个获取对象，避免一次性加载所有对象（有助于处理大量数据）。\n1 2 for person in Person.objects.all().iterator(): print(person.name) as_manager()：将一个类方法转换为模型管理器方法。\n1 2 3 4 5 class MyManager(models.Manager): def with_age(self, age): return self.filter(age=age) Person.objects = MyManager.as_manager() 7. 复合查询\ror_ 和 and_：通过 Q 对象进行复杂的查询条件组合。 1 2 from django.db.models import Q Person.objects.filter(Q(name=\u0026#39;Alice\u0026#39;) | Q(age__gte=18)) 总结\rDjango ORM 提供了丰富的 QuerySet 方法，涵盖从简单到复杂的查询、排序、过滤、聚合、更新等功能。合理使用这些方法，可以极大地提升数据查询和操作的效率。\nonly和defer的区别？\r在 Django 的查询集（QuerySet）中，only() 和 defer() 是两种优化查询性能的方法，目的是减少从数据库中获取的数据量，提升查询速度。但它们的工作方式和适用场景有所不同。\n1. only()\ronly() 用于告诉 Django 只从数据库中获取特定字段的数据，其余字段将不会在查询时一同获取。如果访问了未加载的字段，Django 会在访问该字段时进行额外的数据库查询。\n工作原理：\n当使用 only() 时，Django 只会从数据库中查询你指定的字段，其他字段将在实际访问时通过额外的查询获取。 适用于只需要某些字段的场景，避免加载不必要的数据。 示例：\n1 2 3 4 5 6 7 # 只获取 \u0026#39;name\u0026#39; 和 \u0026#39;age\u0026#39; 字段 queryset = Person.objects.only(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;) for person in queryset: print(person.name) # 不会触发额外的查询 print(person.age) # 不会触发额外的查询 print(person.address) # 访问未指定的字段，触发额外的数据库查询 特点：\n加载指定字段：只加载 only() 中指定的字段，其他字段延迟加载。 可能导致额外查询：当访问未加载的字段时，Django 会进行额外的查询获取该字段的值（N+1 查询问题）。 适用场景：\n适合只需要部分字段的场景，尤其是查询结果中有很多字段但并不都需要立即使用时，可以通过 only() 提前减少数据库负担。 2. defer()\rdefer() 与 only() 相反，它告诉 Django 延迟加载某些字段。即在查询时获取所有字段，除了你指定的字段之外，其他字段将在实际访问时进行额外的查询。\n工作原理：\n使用 defer() 时，Django 会查询除指定字段以外的所有字段。访问被延迟加载的字段时，会触发额外的数据库查询。 示例：\n1 2 3 4 5 6 7 # 延迟加载 \u0026#39;bio\u0026#39; 字段，其他字段会立即加载 queryset = Person.objects.defer(\u0026#39;bio\u0026#39;) for person in queryset: print(person.name) # 不会触发额外的查询 print(person.age) # 不会触发额外的查询 print(person.bio) # 访问延迟加载的字段，触发额外的数据库查询 特点：\n延迟指定字段的加载：在查询时加载所有字段，除了 defer() 中指定的字段，访问这些字段时才会进行数据库查询。 减少初次查询的数据量：通过延迟不需要立即使用的字段，减少初次查询中的数据量。 适用场景：\n当你需要大部分字段，但有一些字段不经常使用时，可以使用 defer() 延迟这些字段的加载，以减少初次查询的开销。 only() 和 defer() 的对比\r特性 only() defer() 目的 只加载指定字段 延迟加载指定字段 初次查询的字段 只查询指定的字段，其余字段延迟加载 查询所有字段，除了被延迟的字段 额外查询 访问未加载的字段时，触发额外的数据库查询 访问延迟加载的字段时，触发额外的数据库查询 适用场景 只关心某些字段，其他字段可以延迟加载 大部分字段需要立即使用，但部分字段可以延迟加载 总结\ronly()：告诉 Django 只查询指定字段，其他字段延迟加载。适合在只需要少数几个字段的场景中使用。 defer()：告诉 Django 查询所有字段，除了那些被延迟加载的字段。适合需要大部分字段但不需要立即使用某些字段的情况。 select_related和prefetch_related的区别？\rselect_related 和 prefetch_related 都用于优化查询并减少数据库查询次数，但它们的作用机制和适用场景有所不同。下面详细介绍它们的区别：\n1. 适用的关系类型\rselect_related：用于一对一和外键（一对多）关系。\n它会使用 SQL 的 JOIN 操作，将相关对象的数据一次性从数据库中取出，减少查询次数。 适用于对象之间有直接的外键或一对一关系的情况。 prefetch_related：用于多对多和反向外键查询（即从“多”查“1”）。\n它会执行额外的查询来获取相关对象的数据，并在 Python 层面将这些查询结果与主查询的结果进行合并。 适用于多对多关系或外键的反向关系。 2. 查询次数\rselect_related：使用 SQL 的 JOIN 操作，只需要一次数据库查询就能获取主对象和相关对象的数据。\n比如，如果你有一个 Person 表和一个与之相关的 Profile 表（外键关系），使用 select_related 会在一次查询中把 Person 和对应的 Profile 数据一起获取。 prefetch_related：会执行多个数据库查询，先查询主对象，再执行额外的查询来获取相关对象的数据。然后在内存中将结果进行匹配。\n比如，当你有 Person 表和 Book 表（多对多关系），使用 prefetch_related 会先查询 Person，然后进行第二次查询来获取 Book 的数据。 3. 性能对比\rselect_related：由于使用了 SQL JOIN，在处理一对一或外键关系时性能通常更好，因为只需要一次查询。但是如果涉及到太多的表 JOIN 操作，查询变得复杂时，性能可能会下降。\nprefetch_related：在多对多关系或反向外键关系下，使用 select_related 不能达到优化的效果，因为 JOIN 复杂的多对多表会产生大量重复数据。此时，prefetch_related 更合适，因为它在 Python 中处理数据，避免了复杂的 JOIN，能更好地减少冗余数据。\n4. 示例\r使用 select_related（外键关系）\r1 2 3 4 # Person 表有一个外键指向 Profile 表 persons = Person.objects.select_related(\u0026#39;profile\u0026#39;).all() # 这只需要一次查询，获取 Person 和 Profile 的数据。 使用 prefetch_related（多对多关系）\r1 2 3 4 # Person 表和 Book 表是多对多关系 persons = Person.objects.prefetch_related(\u0026#39;books\u0026#39;).all() # 这会执行两次查询：一次查询 Person，一次查询 Person 对应的 Book 数据。 5. 总结\r特性 select_related prefetch_related 适用关系 一对一、外键（多对一） 多对多、反向外键 数据库查询次数 只执行一次查询 执行多次查询 工作原理 使用 SQL JOIN 在一次查询中获取所有相关数据 进行多个查询，并在 Python 层面将结果合并 性能表现 适用于简单的关系；太多 JOIN 操作时性能可能下降 适用于复杂关系（特别是多对多），避免大量重复数据 示例场景 Person 和 Profile（外键/一对一） Person 和 Book（多对多） 根据关系类型和性能需求，选择合适的方法可以有效优化 Django ORM 的数据库查询效率。\nfilter和exclude的区别？\r在 Django ORM 中，filter() 和 exclude() 都用于查询数据，但它们的作用相反：\n1. filter()：\r用于筛选出符合条件的记录。 返回满足条件的对象集（QuerySet）。 示例：\r假设你有一个 User 模型，想要筛选出所有 age=30 的用户：\n1 users = User.objects.filter(age=30) 结果：\n返回 age 为 30 的所有用户。 2. exclude()：\r用于排除不符合条件的记录。 返回不满足条件的对象集（QuerySet）。 示例：\r想要查询所有 age != 30 的用户：\n1 users = User.objects.exclude(age=30) 结果：\n返回不是 30 岁的用户。 区别总结：\rfilter()：选出符合条件的记录。 exclude()：排除符合条件的记录，返回其余不满足条件的记录。 对比示例：\r1 2 3 4 5 # 查找年龄为 30 岁的用户 users_filtered = User.objects.filter(age=30) # 查找年龄不是 30 岁的用户 users_excluded = User.objects.exclude(age=30) 返回结果：\rfilter() 返回的 users_filtered 包含所有年龄为 30 岁的用户。 exclude() 返回的 users_excluded 包含所有不是 30 岁的用户。 两个方法可以结合使用，比如你可以先使用 filter() 来细化查询范围，再使用 exclude() 来排除某些结果。\nF和Q的作用?\r在 Django ORM 中，F 和 Q 是两个强大的查询表达式工具，用于构建更加灵活和复杂的查询条件。\n1. F 对象：\rF 对象允许在查询中引用模型字段本身，特别适合需要比较字段之间的值或者对字段进行原子更新的场景。\n主要作用：\r字段之间的比较：可以在查询中比较一个字段与另一个字段的值。 原子更新：在更新操作中可以直接基于现有字段值进行计算（如递增、递减）。 示例：\ra) 字段间比较：\r假设你有一个 Product 模型，包含 price 和 discount_price 两个字段，想要查询 price 大于 discount_price 的产品。\n1 2 3 from django.db.models import F products = Product.objects.filter(price__gt=F(\u0026#39;discount_price\u0026#39;)) 结果：\n返回 price 大于 discount_price 的所有产品。 b) 原子更新：\r假设你想要将某个字段的值基于其现有值增加一定数量，比如增加库存数量。\n1 Product.objects.filter(id=1).update(stock=F(\u0026#39;stock\u0026#39;) + 10) 结果：\n将 id=1 的产品库存增加 10。Django 会直接在数据库层面进行更新，避免了取出、修改再保存的额外步骤。 2. Q 对象：\rQ 对象用于构建更加复杂的查询条件，尤其是需要在查询中使用逻辑运算符（如 AND、OR、NOT）时非常有用。\n主要作用：\r组合复杂的条件：可以通过 \u0026amp;（AND）、|（OR）、~（NOT）操作符组合查询条件。 处理条件之间的逻辑关系：特别是在你需要做 OR 查询或排除某些条件时非常有用。 示例：\ra) OR 查询：\r假设你想查询 age=30 或 name=\u0026quot;John\u0026quot; 的用户。\n1 2 3 from django.db.models import Q users = User.objects.filter(Q(age=30) | Q(name=\u0026#39;John\u0026#39;)) 结果：\n返回年龄为 30 岁的用户或名字为 \u0026ldquo;John\u0026rdquo; 的用户。 b) AND 查询：\r默认情况下，filter() 使用 AND 操作符，但你可以显式使用 \u0026amp; 来构建复杂的 AND 查询。\n1 users = User.objects.filter(Q(age=30) \u0026amp; Q(name=\u0026#39;John\u0026#39;)) 结果：\n返回年龄为 30 且名字为 \u0026ldquo;John\u0026rdquo; 的用户。 c) NOT 查询：\r可以使用 ~ 运算符来表示逻辑 NOT。\n1 users = User.objects.filter(~Q(age=30)) 结果：\n返回年龄不是 30 岁的用户。 3. F 和 Q 结合使用：\rF 和 Q 可以一起使用来构建更复杂的查询。例如，查找所有 price \u0026gt; discount_price 或 stock \u0026lt; 10 的产品：\n1 products = Product.objects.filter(Q(price__gt=F(\u0026#39;discount_price\u0026#39;)) | Q(stock__lt=10)) 结果：\n返回 price 大于 discount_price 或者库存小于 10 的产品。 总结：\rF 对象：用于在查询或更新时引用模型字段本身，支持字段之间的比较和原子更新操作。 Q 对象：用于构建复杂的查询条件，支持逻辑运算（AND、OR、NOT）来组合不同的条件。 values和values_list的区别？\r在 Django ORM 中，values() 和 values_list() 都用于从数据库中提取特定字段的数据，但它们的返回结果形式不同：\n1. values()：\r返回一个字典（dictionary）的 QuerySet，其中每个字典的键是字段名，值是字段的值。 通常用于获取一组对象的特定字段及其对应值，结果类似于字典的列表。 示例：\r假设有一个 User 模型，包含字段 id、username 和 email。\n1 users = User.objects.values(\u0026#39;id\u0026#39;, \u0026#39;username\u0026#39;) 结果：\n1 2 3 4 5 [ {\u0026#39;id\u0026#39;: 1, \u0026#39;username\u0026#39;: \u0026#39;JohnDoe\u0026#39;}, {\u0026#39;id\u0026#39;: 2, \u0026#39;username\u0026#39;: \u0026#39;JaneDoe\u0026#39;}, # ... ] 结果中每个条目是一个字典，包含 id 和 username 字段。 2. values_list()：\r返回一个元组（tuple）的 QuerySet，其中每个元组包含所查询字段的值。 如果只查询一个字段，则可以设置 flat=True 来获取一个简单的列表。 通常用于获取字段值的列表或元组形式，效率上略优于 values()，因为它避免了字典构造的开销。 示例：\ra) 获取多个字段：\r1 users = User.objects.values_list(\u0026#39;id\u0026#39;, \u0026#39;username\u0026#39;) 结果：\n1 2 3 4 5 [ (1, \u0026#39;JohnDoe\u0026#39;), (2, \u0026#39;JaneDoe\u0026#39;), # ... ] 结果是一个元组的列表，每个元组对应 id 和 username 的值。 b) 获取单个字段：\r使用 flat=True 时，只返回一个字段的平铺列表。\n1 usernames = User.objects.values_list(\u0026#39;username\u0026#39;, flat=True) 结果：\n1 [\u0026#39;JohnDoe\u0026#39;, \u0026#39;JaneDoe\u0026#39;, ...] 结果是一个简单的列表，包含所有用户的 username 字段。 区别总结：\r方法 返回类型 示例结果 适用场景 values() 字典的 QuerySet [{'id': 1, 'username': 'JohnDoe'}, ...] 需要键值对时 values_list() 元组的 QuerySet [(1, 'JohnDoe'), (2, 'JaneDoe')] 需要字段值的列表或元组时 values_list(flat=True) 列表（单个字段） ['JohnDoe', 'JaneDoe'] 只需要某个字段的简单列表时 总结：\rvalues()：返回包含字段名和对应值的字典列表，适合需要字段名与值一一对应的场景。 values_list()：返回字段值的元组列表，如果只查询一个字段且使用 flat=True，返回平铺列表，适合只关心字段值本身的场景。 References\rpython web框架django面试题 Django本身提供了runserver，为什么不能用来部署？ ","date":"2024-10-14T20:21:44+08:00","permalink":"http://localhost:1313/p/django%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/","title":"Django面试题（二）"},{"content":"对Django的认识\rDjango是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用其ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。 Django内置的ORM跟框架内的其他模块耦合程度高。应用程序必须使用Django内置的ORM，否则就不能享受到框架内提供的种种基于其ORM的便利； Django适用的是中小型的网站，或者是作为大型网站快速实现产品雏形的工具。 Django模板的设计哲学是彻底的将代码、样式分离；Django从根本上杜绝在模板中进行编码、处理数据的可能。 Django，Flask和Tornado的对比\r框架定位\nDjango：全栈框架，功能全面，内置ORM、认证、后台管理等，适合中大型项目。 Flask：轻量微框架，灵活性高，适合小型应用和需要定制化的项目。 Tornado：异步Web框架，擅长高并发和实时通讯，适合实时系统和高并发场景。 开发效率\nDjango：内置功能多，开发效率高，但灵活性相对较低。 Flask：简洁灵活，开发者有更多技术选择空间，但需自行集成扩展。 Tornado：异步模式高效并发，但开发和调试复杂。 性能与适用场景\nDjango：适合企业级应用，性能一般，但可通过缓存等手段优化。 Flask：轻量，适合API和小型项目，需外部工具提升并发性能。 Tornado：异步架构，适合高并发、WebSocket等实时应用，性能最优。 总结\nDjango：适合功能复杂、需要快速开发的项目。 Flask：适合灵活定制的小型应用或微服务。 Tornado：适合高并发、实时通讯的系统。 Web服务器和Web框架的区别\rWeb服务器即用来接受客户端请求，建立连接，转发响应的程序。至于转发的内容是什么，交由Web框架来处理，即处理这些业务逻辑。如查询数据库、生成实时信息等。 Nginx是一个Web服务器，Django或flask就是Web框架。\n什么是WSGI,uWSGI,uwsgi,aWSGI？\rWSGI，Web服务器网关接口，是一种Web服务器网关接口，它是一个Web服务器（如Nginx，uWSGI等服务器）与Web应用（如Flask框架写的程序）通信的一种规范。当前运行在WSGI协议之上的Web框架有Bottle，Flask，Django uWSGI，是实现了WSGI协议的一个Web服务器。即用来接受客户端请求，转发响应的程序。实际上，一个uWSGI的Web服务器，再加上Django这样的Web框架，就已经可以实现网站的功能了。 uwsgi，uwsgi 是一个与 uWSGI 服务器相关的协议。uwsgi 协议是一种二进制协议，它定义了 uWSGI 服务器与应用程序之间的通信协议。使用 uwsgi 协议，uWSGI 服务器可以与 Python 应用程序通信 aWSGI，异步网关协议接口，一个介于网络协议服务和Python应用之间的标准接口，能够处理多种通用的协议类型，包括HTTP，HTTP2和WebSocket。 WSGI和ASGI的区别\rWSGI是基于HTTP协议模式的，不支持WebSocket，而ASGI的诞生则是为了解决Python常用的WSGI不支持当前Web开发中的一些新的协议标准。同时，ASGI对于WSGI原有的模式的支持和WebSocket的扩展，即ASGI是WSGI的扩展。\nDjango的生命周期\rwsgi,请求封装后交给web框架 （Flask、Django） 中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf、request.session 路由匹配,根据浏览器发送的不同url去匹配不同的视图函数 视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm、templates =\u0026gt; 渲染 中间件，对响应的数据进行处理。 wsgi,将响应的内容发送给浏览器。 什么是FBV和CBV？\rFBV（function base views）： 基于函数的视图，就是在视图里使用函数处理请求。 CBV（class base views）： 基于类的视图，就是在视图里使用类处理请求。\nFBV\r就是使用了函数来处理用户的请求，查看以下实例：\n路由配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # urls.py urlpatterns = [ path(\u0026#34;login/\u0026#34;, views.login), ] # views.py from django.shortcuts import render,HttpResponse def login(request): if request.method == \u0026#34;GET\u0026#34;: return HttpResponse(\u0026#34;GET 方法\u0026#34;) if request.method == \u0026#34;POST\u0026#34;: user = request.POST.get(\u0026#34;user\u0026#34;) pwd = request.POST.get(\u0026#34;pwd\u0026#34;) if user == \u0026#34;runoob\u0026#34; and pwd == \u0026#34;123456\u0026#34;: return HttpResponse(\u0026#34;POST 方法\u0026#34;) else: return HttpResponse(\u0026#34;POST 方法1\u0026#34;) CBV\r基于类的视图，就是使用了类来处理用户的请求，不同的请求我们可以在类中使用不同方法来处理，这样大大的提高了代码的可读性。\n定义的类要继承父类 View，所以需要先引入库：\nfrom django.views import View 执行对应请求的方法前会优先执行 dispatch 方法(在get/post/put\u0026hellip;方法前执行)，dispatch() 方法会根据请求的不同调用相应的方法来处理。\n其实，在我们前面学到的知识都知道 Django 的 url 是将一个请求分配给可调用的函数的，而不是一个类，那是如何实现基于类的视图的呢？ 主要还是通过父类 View 提供的一个静态方法 as_view() ，as_view 方法是基于类的外部接口， 他返回一个视图函数，调用后请求会传递给 dispatch 方法，dispatch 方法再根据不同请求来处理不同的方法。\n路由配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # urls.py urlpatterns = [ path(\u0026#34;login/\u0026#34;, views.Login.as_view()), ] # views.py from django.shortcuts import render,HttpResponse from django.views import View class Login(View): def get(self,request): return HttpResponse(\u0026#34;GET 方法\u0026#34;) def post(self,request): user = request.POST.get(\u0026#34;user\u0026#34;) pwd = request.POST.get(\u0026#34;pwd\u0026#34;) if user == \u0026#34;runoob\u0026#34; and pwd == \u0026#34;123456\u0026#34;: return HttpResponse(\u0026#34;POST 方法\u0026#34;) else: return HttpResponse(\u0026#34;POST 方法 1\u0026#34;) 如何给CBV的程序添加装饰器？\r对单个方法使用装饰器：使用@method_decorator装饰get、post等方法。 1 2 3 4 5 6 7 8 9 from django.utils.decorators import method_decorator from django.contrib.auth.decorators import login_required from django.views.generic import View from django.http import HttpResponse class MyView(View): @method_decorator(login_required) def get(self, request, *args, **kwargs): return HttpResponse(\u0026#34;This is a protected view\u0026#34;) 对整个类视图使用装饰器：使用@method_decorator装饰dispatch方法，影响所有请求方法。 1 2 3 4 5 6 7 8 9 10 11 12 from django.utils.decorators import method_decorator from django.contrib.auth.decorators import login_required from django.views.generic import View from django.http import HttpResponse @method_decorator(login_required, name=\u0026#39;dispatch\u0026#39;) class MyView(View): def get(self, request, *args, **kwargs): return HttpResponse(\u0026#34;This is a protected view\u0026#34;) def post(self, request, *args, **kwargs): return HttpResponse(\u0026#34;This is a protected view for POST request\u0026#34;) 简述MVC和MTV\rMVC（Model View Controller 模型-视图-控制器）\r​ Web服务器开发领域里著名的MVC模式，所谓MVC就是把Web应用分为模型(M)，控制器(C)和视图(V)三层，他们之间以一种插件式的、松耦合的方式连接在一起，模型负责业务对象与数据库的映射(ORM)，视图负责与用户的交互(页面)，控制器接受用户的输入调用模型和视图完成用户的请求，其示意图如下所示：\nMVC模式示意图 M-\u0026gt;Model:模型，主要负责在数据库中对数据的存取操作 V-\u0026gt;View:视图，负责显示数据，通常是前端界面，如HTML页面、UI元素等。它接收用户输入并将其传递给Controller。 C-\u0026gt;Controller:控制器，充当Model和View之间的桥梁。它处理来自View的用户请求，调用Model中的业务逻辑，返回结果给View进行显示。 MTV（Model Templates View 模型-模板-视图）\rDjango的MTV模式本质上与MVC是一样的，也是为了各组件之间保持松耦合关系，只是在定义上有些不同，Django的MTV分别是：\nM-\u0026gt;模型(Model)：和MVC中的Model类似，处理与数据相关的内容，定义数据库的结构和操作方法 T-\u0026gt;模板(Template)：相当于MVC中的View，负责将数据呈现给用户。模板通过Django的模板语言生成动态HTML页面 V-\u0026gt;视图(View)：与MVC的Controller功能类似，负责处理用户请求和业务逻辑，调用Model获取数据，并将结果传递给Template进行渲染 还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template，MTV的响应模式如下所示：\nMTV模式示意图 ​ 一般是用户通过浏览器向我们的服务器发起一个请求(request)，这个请求回去访问视图函数，（如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户），视图函数调用模型，模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。\nMVC和MTV的区别\rMVC中的V的目的是呈现那个数据，而MTV的V的目的是数据如何呈现\n也就是把MVC中的View分成了视图（展现哪些数据）和模板（如何展现）2个部分，而Contorller这个要素由框架自己来实现了，我们需要做的就是把（带正则表达式的）URL对应到视图就可以了，通过这样的URL配置，系统将一个请求发送到一个合适的视图。\nDjango框架中配置url路由时name的作用\r主要是通过name的值，来查找url地址，可以理解为反射作用（别名）。在html模板中使用name来反射url优势就是后期url规则发生改变之后，只需调整urls.py即可，所有的模板文件都不需要修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # urls.py urlpatterns = [ path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;sum/\u0026#39;, views.add, name=\u0026#34;add\u0026#34;), path(\u0026#39;get_url/\u0026#39;, views.get_url, name=\u0026#34;test\u0026#34;), path(\u0026#39;index/\u0026#39;, views.index), ] # views.py def add(request): return HttpResponse(\u0026#39;你访问了第一个url路由\u0026#39;) def get_url(request): # reverse()这个函数就是根据url路由的name参数，来反向获取url地址的方法 # 所以，url路由的name参数不仅仅可以在模板中使用{% url \u0026#39;add\u0026#39; %}，也可以在view.py中使用 result = reverse(\u0026#39;add1\u0026#39;, args=(123, 456)) return HttpResponse(result) 1 2 3 4 5 6 7 {# 上述使用name字段的url路由设置方法在html文件中的应用方式如下： #} {# url是固定写法，表示当前要加载的是url地址。\u0026#39;add\u0026#39;表示url路由对应的name参数值。 #} {# 要加载name=\u0026#34;add\u0026#34;的这个url地址。 #} \u0026lt;a href=\u0026#34;{% url \u0026#39;add\u0026#39; %}\u0026#34;\u0026gt;第一个url路由\u0026lt;/a\u0026gt; {# 通过name的值\u0026#34;add1\u0026#34;，反向获取带有参数的url地址 #} \u0026lt;a href=\u0026#34;{% url \u0026#39;add1\u0026#39; 10 25 %}\u0026#34;\u0026gt;计算\u0026lt;/a\u0026gt; 列举django的内置组件？\rDjango 是一个功能强大的全栈框架，提供了大量内置组件，帮助开发者快速构建和维护Web应用。这些内置组件涵盖了从数据管理、用户身份认证到安全性、性能优化等方面的需求。\n以下是 Django 的一些重要内置组件：\n1. 模型（Model）\rORM（Object-Relational Mapping）：Django 提供了内置的 ORM 系统，帮助开发者通过 Python 类定义数据库表结构，而不需要直接写 SQL。常用组件包括： models.Model：基础模型类。 字段类型：CharField，IntegerField，DateField 等。 关系字段：ForeignKey，ManyToManyField，OneToOneField。 2. 视图（View）\r基于函数的视图（FBV）：使用普通的 Python 函数处理 HTTP 请求，例如： 1 2 def my_view(request): return HttpResponse(\u0026#34;Hello, world!\u0026#34;) 基于类的视图（CBV）：提供了一系列通用视图类，简化了开发常见的视图逻辑： ListView：用于展示对象列表。 DetailView：展示单个对象的详细信息。 CreateView，UpdateView，DeleteView：处理对象的创建、更新、删除操作。 3. 模板引擎（Template Engine）\rDjango 内置了一个模板系统，允许开发者使用模板语言生成动态 HTML 页面。常用的模板标签和过滤器包括： 变量输出：{{ variable }} 控制结构：{% for item in list %} ... {% endfor %}，{% if condition %} ... {% endif %} 过滤器：{{ name|upper }}，{{ date|date:\u0026quot;Y-m-d\u0026quot; }} 4. URL 路由（URL Routing）\rDjango 提供了灵活的 URL 路由系统，允许开发者通过 urls.py 文件定义 URL 模式与视图函数的映射： 1 2 3 4 5 6 from django.urls import path from . import views urlpatterns = [ path(\u0026#39;home/\u0026#39;, views.home_view, name=\u0026#39;home\u0026#39;), ] 支持正则表达式匹配和命名路由。 5. 表单处理（Forms）\rDjango 提供了强大的表单处理组件，支持表单生成、验证、以及与模型的绑定。 forms.Form：手动定义表单结构。 forms.ModelForm：自动生成与模型关联的表单。 支持表单字段验证和错误处理。 6. 认证和授权系统（Authentication and Authorization）\rDjango 内置了完整的用户身份认证和权限管理系统： django.contrib.auth：提供用户模型、身份验证、权限、用户组等。 常用组件： User 模型：用于用户注册、登录。 LoginRequiredMixin：用于限制用户访问某些视图。 PermissionRequiredMixin：基于权限控制视图的访问。 7. 管理界面（Admin）\rDjango 内置了强大的后台管理界面，无需额外开发即可管理模型数据。 django.contrib.admin：自动生成管理后台，通过 admin.site.register 将模型注册到后台。 支持自定义表单、过滤器、搜索等功能。 8. 中间件（Middleware）\rDjango 提供了中间件机制，可以在请求和响应的处理过程中添加额外的逻辑。 常见的内置中间件包括： SecurityMiddleware：处理安全相关的功能（如强制 HTTPS）。 AuthenticationMiddleware：处理用户的身份认证。 SessionMiddleware：启用会话支持。 CommonMiddleware：处理URL重定向、内容长度等。 9. 消息框架（Messages Framework）\rDjango 的消息框架允许在不同请求之间传递一次性消息（如成功提示、错误消息）。 django.contrib.messages：常用于提示用户操作结果，如表单提交成功。 使用 messages.add_message 或 messages.success，messages.error 等方法显示消息。 10. 文件上传处理（File Handling）\rDjango 提供了简便的文件上传和处理机制。 FileField 和 ImageField：用于在模型中定义文件上传字段。 request.FILES：处理上传的文件。 11. 信号（Signals）\rDjango 提供了信号机制，允许在某些事件发生时触发特定的回调函数。 常用信号：pre_save，post_save，pre_delete，post_delete。 开发者可以使用信号来处理特定事件，如模型保存后执行额外逻辑。 说一下Django，MIDDLEWARES中间件的作用和应用场景？\r中间件是介于request与response处理之间的一道处理过程,用于在全局范围内改变Django的输入和输出。\n简单的来说中间件是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作\n例如：\nDjango项目中默认启用了csrf保护,每次请求时通过CSRF中间件检查请求中是否有正确token值 当用户在页面上发送请求时，通过自定义的认证中间件，判断用户是否已经登陆，未登陆就去登陆。 当有用户请求过来时，判断用户是否在白名单或者在黑名单里 列举django中间件的5个方法？\r方法 作用 process_request(self, request) 主要方法。请求刚进来时，执行视图函数之前调用。(无return) process_view(self, request, callback, callback_args, callback_kwargs) URL路由匹配成功后，执行视图函数之前调用，拿到视图函数对象，及其所有参数。(无return) process_exception(self, request, exception) 执行视图函数中遇到异常时调用。(无return) process_template_response(self, request, response) 很少用。执行了render()渲染方法后调用。(有return) process_response(self, request, response) 主要方法。执行视图函数结束之后有响应时调用。(有return) References\rpython web框架django面试题 https://www.runoob.com/django/django-views-fbv-cbv.html Django简介与MTV模式 Django框架中配置url路由时name的作用 列举django中间件的5个方法？以及django中间件的应用场景？ ","date":"2024-10-13T21:57:51+08:00","permalink":"http://localhost:1313/p/django%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/","title":"Django面试题（一）"},{"content":"宇宙级免责声明\r本人无意泄露各高校试题，严格遵守任何保密协议，如有不妥随时私信，本人将立刻删除相关内容。本文章的所有内容都仅代表本人观点，如有不同观点，欢迎友善交流~\n写在前面\r关于信息差：保研是一场重大的信息差备赛，有的同学可能从大一刚入学就开始准备了，有的到大三下才真正开始了解保研（比如我），大三下开始会很吃亏！！规划的太晚，不清楚自己想走学术还是就业，没有及时套磁（很多三四月份甚至更早就开始联系导师了），总之早点确认自己的方向总不会错啦。这里也强烈推荐计算机保研er的破茧利器——全国最大非商业用爱交流计算机保研交流群（虽然潜水几个月lru了好几次hh，但是真心推荐！！） 关于套磁：其次就是要勇敢地去套磁，其实整个保研周期我的套磁都挺失败的，周围一套一个准，我套磁之前总会想着老师会不会嫌自己太菜、经历不匹配啥的，总之有点焦虑过头而错过了很多好时机（infj哭死），其实大家都差不多，甚至水平不如自己，勇敢冲就是了！ 关于海王：夏令营我的整体策略就四个字：多多益善。相较于担心老师那边不好回绝，在夏令营阶段更需要担心的是能否拿到一个保底的offer（大佬除外），也有部分提前套磁好的弱com的同学，自然也不必参加过多的夏令营，毕竟确实耗钱耗时间耗精力。当然，在有铁offer并且满意的前提下，也应该及时释放掉多余的offer，减少对老师招生带来的影响，也避免学弟学妹被拉入黑名单。 个人情况\r院校：次九 专业排名：SE，前2% 竞赛：非算法类竞赛若干，有果酱，没有牌子 科研：一段本校隐私计算方面的科研，B刊在投 工程：一段医学交叉的横向，从0到1搭起来的系统，比较solid，基本都能答上 外语：CET-6（不到500，和CET-4成绩相差巨大，是个雷点） 个人意向：70%就业向，title == 导师 \u0026gt; 方向 \u0026raquo; 地域，因为就业意向偏重，主要还是看导儿放不放实习 最终去向：清软专硕 前期准备\r前期主要是在各种文书的准备和无效套磁中（悲），套磁就不误人子弟了。文书方面主要包括了简历、个人陈述、PPT、套磁信、推荐信、中英文自我介绍、成绩单、排名证明……\n简历我这里用的是超级简历，当然也可以直接用word做，绿裙里有相关的模板可以拿来用，主要是要不断迭代完善，建议是保留好每一次的修改，我的简历从五月末到929已经出了15版，针对于每次面试老师偏好的点进行针对性修改完善，也伴随着可能出现科研成果上的更新而更新，并且一定要对简历上的每一个字负责，问穿就尴尬了。\n然后就是个人陈述，有一部分学校是要求提交个人陈述的，这个建议提前写好，一般学校也不会以此为参考，主要准备好500、1000和2000字三个版本，直接针对每个学校稍微改改交上去就好。\nPPT的话可以提前准备好一份，模块化处理，比如基本情况介绍可以1~2页，简单列一下rk、奖学金、竞赛之类的，然后项目经历每个3~4页，科研经历每个5~6页，针对每个学校的要求适当增删，套磁面试的时候一般不太卡时间，适当详细一点是没问题的。可以用本校的模板，也可以用面试学校的模板，但一定要做到整洁干净，不能太花哨，动画也建议少，以免播不出来出岔子。\n中英文自我介绍建议都准备1分钟、3分钟和5分钟版本的，一定要做到肌肉记忆般熟练，同简历一样，也要对自己说的每一句话有百分之一百的把握。\n推荐信的话并不是每个学校都需要，但是提前准备好总没错，一般是要两名职称副教授以上的（计算所需要两名教授职称的），建议直接找好两位教授，能要到电子签名最好（虽然一般不给）。\n夏令营情况\r整体来说，我的夏令营投递是偏保守的（真的很担心没保底），基本投了所有学校（但主要集中在华五），并且大部分都是学硕，导致整个七月份都是在奔波度过，下面就是我的夏令营基本情况。\n院校 入营情况 是否优营 备注 南大cs学硕 否 否 线上被刷 南大ai学硕 否 否 感觉和cs被刷有一定关系 南大se学硕 否 否 感觉和cs被刷有一定关系 人大gl学硕 否 否 本来也没抱啥希望 人大信院学硕 否 否 迷之bar。。。 复旦cs学硕 否 否 普信旦是这样的，后面紧急扩散了 北大软微 是 否 科研向了，拒绝了就包没优营的 武大cs学硕 是 是 上交电院se直硕 是 是 其实只有联培。。。 中科院计算所学硕 否（计算所霸面） 否 被三个组霸面，因为方向问题都拒了 中科院软件所学硕 是（和sjtu冲突） 否 中大cs学硕 是（和sjtu冲突） 否 科大网安学硕 是 是 人均优营，重要是双选，但是还是穿了 浙大CAD\u0026amp;CG 是 是 项目制考核，夏令营只有直博 哈工深CS学硕 否 否 今年bar很高 南大CS学硕\r南大今年开的很早，五月初就出结果了，但是南大需要先双机位通过线上测试才能够参加线下营，南大也是出了名的强com，试题的范围涉及很广，我甚至还提前一天去开了间酒店通宵复习408（血亏），结果今年考了不少编译原理和离散，这简直对我来说是天崩开局，因此也就无疾而终了。总之还是要感谢一下南大肯给我入营的机会，否则我的夏令营投递策略还会更加保守。\n（ps: 听说南大给的酒店巨好，可惜无福消受了555）\n人大信院学硕\r这我是万万没想到的，整个保研周期最让我感到震惊的bar，之前一直以为人大信院是个保底的存在，也联系好了一个评价巨好的老师，结果居然连营都没入，甚至老师都怀疑我是不是报错了，后面也替我亲自去问了教务（真的好感动），感觉是我整个保研过程中最看好我的老师了555。\n亲自问学院（好好的老师啊啊啊啊） 北大软微\r为了错峰出行，也为了进入梦校，软微我报了方向2，通过初筛后还有一轮论文筛，会给个list，其中挑一篇感兴趣的写一篇阅读报告，方向2感觉真的不太卷，而且和我本科研究方向比较契合，只要多看几遍论文，仔细写好阅读报告基本都能入。\n作为第一个线下营，上来就北大对我这个菜鸟十分不友好，提前一天就到了大兴，不得不说软微这个位置确实有点偏僻，校区也很小。\n软微校门 软微夏令营今年分为了三天，第一天是宣讲和各个方向的座谈会，后面两天笔试+面试，不过方向2人不算多，6号基本都结束了。\n笔试的难度不高，30min手撕三道，基本都能写出来。面试的话只能提交3页的pdf还是有点局促的，也算是最罕见的要求了，面试的老师都挺和蔼的，不会的话也不会过多为难，整体气氛十分欢快。\n后续：面试后陆续有三位老师联系了我，但知道了不放实习+本人想要尝试更多学校，和父母、学长仔细斟酌后还是放弃了offer（软微要承诺一定来才会发优营）。\nps：软微夏令营在科研向的道路上渐行渐远了，虽然也有羊导，但是今年方向2基本都是搞科研的了（毕竟报销学费）\n算是拒绝过北大的人了，老师也超nice的！！ 整体来说，软微的夏令营体验还是相当棒的，无论是入营礼包（T恤+饭票），还是没有架子的老师们，都给人一种额外的归属感。面试后我还去绕天安门附近夜骑了一圈，尝了卤煮（好吃嘿嘿）、豆汁儿（难以接受），这次首都之行还是很满意的！ 武大CS学硕\r武大夏令营开的算是不错的了，甚至提供两晚汉庭+包饭，离学校超近，校园也是超好看的（可惜樱花季已经过了）。\n武大校门 整体来说，夏令营时间安排挺紧凑的，第一天上午报到+宣讲，下午机试，因为早上要很早报到+中午没睡，下午脑子一团浆糊，机试五道题，涉及的算法还挺广的，最后就做出了一两道，其他纯在骗分，机试直接原地大爆炸。 第二天就只有面试了，面试是坐在大方桌的主持人座，老师在两侧，摄像机从对面录像，因为有了软微的经验，面试的整个过程还是相当顺利的，都是简历面，也基本都能答上来。\n傍晚的武大 后续：过了没几天发了优营名单，背景评估、机试分、面试分三者综合打出一个综合分，感觉算是十分公开透明的了（点赞）。我虽然在优营名单中，但志不在此，就没有去联系导师了。\n武大是我高考的梦校，尽管不是最终去向，但还是很感激武大能够给我这次机会~\n上交软院（智慧应用方向）\r上交CS直硕的bar一直很高，为了求稳我报了软院（但是软院感觉除了IPADS性价比都不高，但IPADS也是出了名的难）。\n上交软院在线下参营前会公布各个方向（线上宣讲）及其具体的入营任务，大多数是读论文，选定了论文就是选定了方向。后面还会有一次方向调整的机会，通过邮件的方式告诉你各个方向的竞争指数，为了错峰选了智慧应用，但是后来出了竞争指数智慧应用却是最高的（大家的想法都一样hh），不过后面还是头铁上了（懒得改了），结果到最后统计的时候智慧应用反而只剩七个了（博弈论算是玩明白了）。\n上交（闵行）校门 因为上交和武大只隔了一天，因此在武汉多住一晚后直接从武汉出发赶往上海了。上交软院夏令营是在闵行校区，感觉特别偏僻，周围配套还不是很完善，地铁站离学校还有一段距离，但学校大是真的大。\n夏令营分为了两天，考核是常规的机试+面试，但是机试很不常规，非OJ，一道超大模拟题，可以带一些离线资料（然并卵），最后提交一个压缩包上去。第二天面试，老师都挺好的，不会过多刁难你，印象里问了好多问题，有数据结构，也有简历面，不过论文倒是一点没问（奇怪）。\n在面试完后，有老师打电话给我，说我面试还不错，问我是否考虑，我当即答应了下来。不过上交得到九月才出名额，后面到了被告知这个方向只有联培了，遂作罢。\n整体来说，感觉上交硕士的本校保护很厉害，无论是宣讲还是最后的给的名额，给外校的基本都只有联培的名额（并非说联培不好，叠甲）。但是软院的招生老师还是很好滴，无论是前期的通知还是后续打电话问是否接受联培名额，整体给人的感觉很亲切负责。\n科大网安\r科大是出了名的对号入座，非CS的很难入CS营，又因为网安大部分老师是从6系和CS那边调过来的，方向没这么偏向安全，因此就报了网安。 科大的夏令营感觉是全场最佳了，酒店、大礼包、一百块的饭卡，还有超级盛大的开营仪式，而且全程有志愿者对接，简直仪式感拉满！！\n无敌的仪式感 夏令营分为了三天，第一天就是学校和各个学院的介绍+合影。第二天则是实验室介绍，如果打算来科大的千万要抓住这个机会，这不仅仅是参观，还要趁此机会加心仪实验室的联系方式，主动交流占坑。第三天的面试分为了上下午两场，一场十分钟，区别在于是否有英文问题，感觉更多是走个过场，不会过深挖掘。\n科大基本人均优营，没有效力，需要和老师完成双选才是铁offer，建议提前联系好导师面试，强导基本在夏令营开始前就被占满了，并且科大的预推免基本没有名额，得看鸽子（今年网安鸽子很多，到929都还有坑位）。\n科大的夏令营真的办得很棒，食宿、文创什么的都拉满了（据说书包还被倒卖出去不少hh），最后也联系上了导师，不过因为后面拿到了清软的offer就主动释放了。\n浙大CAD\u0026amp;CG\r浙大根据实验室不同，安排的项目考核时长也相应不同，有的长达两个月，有的可能就一个多星期（比如我们），考核内容基本是以论文复现为主，竞争总体不会特别激烈，因为只有外校的，并且到后面很多都坚持不下去。\nCAD\u0026CG CAD\u0026CG是在紫金港，是真的又大又好看（别人家的学校），实验室的师兄师姐和老师也很nice！！不过后面把我专业调剂了，并且和个人的规划方向不太相同，主动释放了offer。 预推免情况\r夏令营在拿到科大和浙大的铁offer后，预推免就能更大胆些了，目标就主要是一些夏令营没能入营与清北两所了。\n院校 是否入营 是否优营 备注 哈工深cs学硕 否 否 hitsz你拒我两次555 清华软院专硕 是 是 最终去向 清华深圳专硕 否 否 它甚至发拒信，哭死 复旦cs学硕 是 否 开摆 北大软微 否 否 今年大部分要跟实验室课题了，头铁网安方向，寄 北大深圳 否 否 没有套磁，意料之中 南大ai学硕 否 否 南大se学硕 是 否 准备清软，放弃入营 清华软院专硕\r这是我的预一营，最初我就是抱着报来试试的心态，没想到能够顺利入营，那时候高兴的要起飞了。招生老师也超级好，虽然没有建群，但是基本有求必应，并且所有通知都是邮箱短信双提醒（赞）。\n入营邮件 清华的前期流程算是比较复杂的了，需要老师在线填写推荐信（真的感觉很不好意思），别的按照要求填上就好。\n清软的考核分为了两天，第一天机试，可以带参考资料，我带了AcWing的模板，一共三题，第一题打卡题，第二题我用了模板很快也AC了，最后一题实在是想不出来了，罚坐（有大佬一个半小时结束战斗xm）。第二天面试，老师们都特别和蔼，不会刻意刁难，虽然我英文题爆炸了（被cue了六级），但是老师还是没有过多为难。\n虽然机试20%+面试80%，但是我感觉面试大家的差距不会很大，反而机试十分重要，占比是主要的，我也难得幸运了一次（开心），也可能是自己本身放低了预期，没想着能够进入清华，心态比较好吧hh\n复旦CS学硕\r在拿了清软的offer后，复旦就没有过多去准备了，第一天机试（5题），第二天英文面试（甚至单拎出来，就五分钟，可能这天更多是联系导师吧），第三天就是专业面试了（问了超多专业课，根本不会，感觉要把老师题库问完了，一直在看结束没xs）\n9.29终章\r9.28填好系统后，9.29就等清华发offer啦，虽然比别的学校都要晚点hh，但是等待是值得的~\n上岸咯 个人总结\u0026amp;建议\r上圣经！！\n保研圣经 关于心态：在拿到清软offer前，其实一直没有一个满意的offer，总是差点意思，这也导致了夏令营和预推免这段空档我并不轻松，时常会做噩梦惊醒。因此，我认为放平心态十分重要，我身边既有夏0营但最后保研华五的，也有拿着一堆夏令营但最后去向一般的，夏令营20%的人掌握了80%的offer，但最终只能留下一个，复旦在十月份还在紧急扩散呢，策略不同势必会导致不同的入营情况，没有必要去刻意地对比，查漏补缺，针对性补充完全来得及。 关于提前进组：整个保研周期从夏令营到9.29大概三个月，不算长，但真正的准备可能从大三上就开始了，提前进组实习能够十分有效提高你在保研的竞争力，如果恰好是弱com，那直接提前锁定了。 关于入营：选择性入营，选择大于努力，参加过多营的弊端很明显，耗时耗精力，更是没有时间去停下来反思总结，十分考验个人的调整能力，适当的放弃能更全身心地准备梦校。 关于机试：算法很重要，我算法从大三下开始，把leetcode hot100三刷，又在夏令营和预推免之间的空窗期把AcWing基础算法课刷完，其实整体是有点赶的，建议还是尽早做准备，算法无法一蹴而就。 关于面试：可以准备好简历带过去，建议穿的干净一点，面试过程中不卑不亢，自信而不失谦逊，言语铿锵有力，不必担心老师会瞧不上你的科研，也不应频繁打断老师提问，张弛有度、彬彬有礼即可。 关于人品：我认为在9.29前如果有心仪且铁offer时，应该把其他的offer及时释放掉，尽可能少的影响老师的招生，也能将offer给到有需要的人。 结语\r没有什么根本来不及，种一棵树最好的时候是十年前，其次是现在，我们需要的是更多勇气。\n在这里，我要感谢一路帮助我的老师、学长、同学、朋友们，精辟独到的建议指引我正确的方向，我也要感恩一直以来支持和鼓励我的父母和女朋友，在我最需要的时候出现在我身边，支撑着我坚持到最后！\n","date":"2024-10-13T14:29:12+08:00","permalink":"http://localhost:1313/p/%E4%BF%9D%E7%A0%94%E5%9B%9E%E5%BF%86%E5%BD%95/","title":"保研回忆录"},{"content":"My First Blog\rJust memory my first blog. Nothing else~\n","date":"2024-10-11T21:03:48+08:00","permalink":"http://localhost:1313/p/my-first-post/","title":"My First Post"}]